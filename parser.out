Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty
Rule 2     variables -> VARIABLES variablesU
Rule 3     variables -> empty
Rule 4     variablesU -> variablesD
Rule 5     variablesU -> empty
Rule 6     variablesD -> ID np_addVariableToStack COMA variablesD
Rule 7     variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU
Rule 8     variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU
Rule 9     functions -> functionsU
Rule 10    functions -> empty
Rule 11    functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD
Rule 12    functionsD -> functions
Rule 13    functionsD -> empty
Rule 14    func_type -> INT empty
Rule 15    func_type -> FLOAT empty
Rule 16    func_type -> CHAR empty
Rule 17    func_type -> VOID empty
Rule 18    var_type -> INT empty
Rule 19    var_type -> FLOAT empty
Rule 20    var_type -> CHAR empty
Rule 21    receive_params -> ID COLON var_type np_receiveParams receive_paramsD empty
Rule 22    receive_params -> empty
Rule 23    receive_paramsD -> COMA receive_params empty
Rule 24    receive_paramsD -> empty
Rule 25    send_params -> hyper_exp np_sentParam send_paramsD empty
Rule 26    send_params -> empty
Rule 27    send_paramsD -> COMA send_params empty
Rule 28    send_paramsD -> empty
Rule 29    block -> L_BRACE blockU R_BRACE empty
Rule 30    blockU -> statement blockD np_emptyStacks empty
Rule 31    blockU -> empty
Rule 32    blockD -> blockU empty
Rule 33    blockD -> empty
Rule 34    statement -> assignment SEMICOLON empty
Rule 35    statement -> call np_isStatement SEMICOLON empty
Rule 36    statement -> return SEMICOLON empty
Rule 37    statement -> read SEMICOLON empty
Rule 38    statement -> write SEMICOLON empty
Rule 39    statement -> decision empty
Rule 40    statement -> conditional empty
Rule 41    statement -> non_conditional empty
Rule 42    statement -> empty
Rule 43    assignment -> ID np_addID EQUAL np_addOperator hyper_exp np_assignment empty
Rule 44    assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty
Rule 45    call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty
Rule 46    return -> RETURN L_PAREN hyper_exp np_return R_PAREN empty
Rule 47    read -> READ L_PAREN ID np_read R_PAREN empty
Rule 48    write -> WRITE L_PAREN writeD R_PAREN empty
Rule 49    writeD -> hyper_exp np_write empty
Rule 50    writeD -> STRING np_string empty
Rule 51    decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty
Rule 52    decisionU -> ELSE np_startDecisionElse block empty
Rule 53    decisionU -> empty
Rule 54    conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty
Rule 55    non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty
Rule 56    for_assignment -> ID np_addIDFor EQUAL np_addOperator hyper_exp np_for_assignment empty
Rule 57    operatorA -> PLUS np_addOperator empty
Rule 58    operatorA -> MINUS np_addOperator empty
Rule 59    operatorT -> MULT np_addOperator empty
Rule 60    operatorT -> DIV np_addOperator empty
Rule 61    operatorL -> OR np_addOperator empty
Rule 62    operatorL -> AND np_addOperator empty
Rule 63    operatorR -> LESS np_addOperator empty
Rule 64    operatorR -> GREATER np_addOperator empty
Rule 65    operatorR -> LESSEQUAL np_addOperator empty
Rule 66    operatorR -> GREATEREQUAL np_addOperator empty
Rule 67    operatorR -> EQUALTO np_addOperator empty
Rule 68    operatorR -> DIFF np_addOperator empty
Rule 69    hyper_exp -> super_exp np_doHyperExp hyper_expU
Rule 70    hyper_expU -> operatorL hyper_exp empty
Rule 71    hyper_expU -> empty
Rule 72    super_exp -> exp np_doSuperExp super_expU
Rule 73    super_expU -> operatorR super_exp empty
Rule 74    super_expU -> empty
Rule 75    exp -> term np_doExp expU
Rule 76    expU -> operatorA exp
Rule 77    expU -> empty
Rule 78    term -> factor np_doTerm termU
Rule 79    termU -> operatorT term
Rule 80    termU -> empty
Rule 81    factor -> varcte empty
Rule 82    factor -> call np_isExpression empty
Rule 83    factor -> L_PAREN hyper_exp R_PAREN empty
Rule 84    varcte -> ID np_addID empty
Rule 85    varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
Rule 86    varcte -> INTVAL np_addConstInt empty
Rule 87    varcte -> FLOATVAL np_addConstFloat empty
Rule 88    varcte -> CHARVAL np_addConstChar empty
Rule 89    empty -> <empty>
Rule 90    np_program -> <empty>
Rule 91    np_endProgram -> <empty>
Rule 92    np_addFunction -> <empty>
Rule 93    np_endFunction -> <empty>
Rule 94    np_main -> <empty>
Rule 95    np_addVariable -> <empty>
Rule 96    np_addVariableToStack -> <empty>
Rule 97    np_addArray -> <empty>
Rule 98    np_addID -> <empty>
Rule 99    np_fakeBottom -> <empty>
Rule 100   np_addArrayID -> <empty>
Rule 101   np_addConstInt -> <empty>
Rule 102   np_addConstFloat -> <empty>
Rule 103   np_addConstChar -> <empty>
Rule 104   np_call_era -> <empty>
Rule 105   np_call_gosub -> <empty>
Rule 106   np_isStatement -> <empty>
Rule 107   np_isExpression -> <empty>
Rule 108   np_addOperator -> <empty>
Rule 109   np_doTerm -> <empty>
Rule 110   np_doExp -> <empty>
Rule 111   np_doSuperExp -> <empty>
Rule 112   np_doHyperExp -> <empty>
Rule 113   np_assignment -> <empty>
Rule 114   np_read -> <empty>
Rule 115   np_write -> <empty>
Rule 116   np_string -> <empty>
Rule 117   np_return -> <empty>
Rule 118   np_startDecision -> <empty>
Rule 119   np_startDecisionElse -> <empty>
Rule 120   np_endDecision -> <empty>
Rule 121   np_conditionalBefore -> <empty>
Rule 122   np_conditionalDuring -> <empty>
Rule 123   np_conditionalAfter -> <empty>
Rule 124   np_addIDFor -> <empty>
Rule 125   np_for_assignment -> <empty>
Rule 126   np_boolFor -> <empty>
Rule 127   np_endCondition -> <empty>
Rule 128   np_sentParam -> <empty>
Rule 129   np_receiveParams -> <empty>
Rule 130   np_paramValidation -> <empty>
Rule 131   np_emptyStacks -> <empty>
Rule 132   notifError -> <empty>

Terminals, with rules where they appear

AND                  : 62
CHAR                 : 16 20
CHARVAL              : 88
COLON                : 7 8 21
COMA                 : 6 23 27
DIFF                 : 68
DIV                  : 60
DO                   : 54 55
ELSE                 : 52
EQUAL                : 43 44 56
EQUALTO              : 67
FLOAT                : 15 19
FLOATVAL             : 87
FROM                 : 55
FUNCTION             : 11
GREATER              : 64
GREATEREQUAL         : 66
ID                   : 1 6 7 8 11 21 43 44 45 47 56 84 85
IF                   : 51
INT                  : 14 18
INTVAL               : 8 86
LESS                 : 63
LESSEQUAL            : 65
L_BRACE              : 29
L_BRACKET            : 8 44 85
L_PAREN              : 1 11 45 46 47 48 51 54 55 83
MAIN                 : 1
MINUS                : 58
MULT                 : 59
OR                   : 61
PLUS                 : 57
PROGRAM              : 1
READ                 : 47
RETURN               : 46
R_BRACE              : 29
R_BRACKET            : 8 44 85
R_PAREN              : 1 11 45 46 47 48 51 54 55 83
SEMICOLON            : 1 7 8 34 35 36 37 38
STRING               : 50
THEN                 : 51
TO                   : 55
VARIABLES            : 2
VOID                 : 17
WHILE                : 54
WRITE                : 48
error                : 

Nonterminals, with rules where they appear

assignment           : 34
block                : 1 11 51 52 54 55
blockD               : 30
blockU               : 29 32
call                 : 35 82
conditional          : 40
decision             : 39
decisionU            : 51
empty                : 1 3 5 10 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 70 71 73 74 77 80 81 82 83 84 85 86 87 88
exp                  : 72 76
expU                 : 75
factor               : 78
for_assignment       : 55
func_type            : 11
functions            : 1 12
functionsD           : 11
functionsU           : 9
hyper_exp            : 25 43 44 44 46 49 51 54 55 56 70 83 85
hyper_expU           : 69
non_conditional      : 41
notifError           : 
np_addArray          : 8
np_addArrayID        : 44 85
np_addConstChar      : 88
np_addConstFloat     : 87
np_addConstInt       : 86
np_addFunction       : 11
np_addID             : 43 84
np_addIDFor          : 56
np_addOperator       : 43 44 56 57 58 59 60 61 62 63 64 65 66 67 68
np_addVariable       : 7
np_addVariableToStack : 6
np_assignment        : 43 44
np_boolFor           : 55
np_call_era          : 45
np_call_gosub        : 45
np_conditionalAfter  : 54
np_conditionalBefore : 54
np_conditionalDuring : 54
np_doExp             : 75
np_doHyperExp        : 69
np_doSuperExp        : 72
np_doTerm            : 78
np_emptyStacks       : 30
np_endCondition      : 55
np_endDecision       : 51
np_endFunction       : 11
np_endProgram        : 1
np_fakeBottom        : 44 85
np_for_assignment    : 56
np_isExpression      : 82
np_isStatement       : 35
np_main              : 1
np_paramValidation   : 45
np_program           : 1
np_read              : 47
np_receiveParams     : 21
np_return            : 46
np_sentParam         : 25
np_startDecision     : 51
np_startDecisionElse : 52
np_string            : 50
np_write             : 49
operatorA            : 76
operatorL            : 70
operatorR            : 73
operatorT            : 79
program              : 0
read                 : 37
receive_params       : 11 23
receive_paramsD      : 21
return               : 36
send_params          : 27 45
send_paramsD         : 25
statement            : 30
super_exp            : 69 73
super_expU           : 72
term                 : 75 79
termU                : 78
var_type             : 7 8 21
varcte               : 81
variables            : 1 11
variablesD           : 4 6
variablesU           : 2 7 8
write                : 38
writeD               : 48

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty

    PROGRAM         shift and go to state 2

    program                        shift and go to state 1

state 1

    (0) S' -> program .



state 2

    (1) program -> PROGRAM . ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty

    ID              shift and go to state 3


state 3

    (1) program -> PROGRAM ID . np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty
    (90) np_program -> .

    SEMICOLON       reduce using rule 90 (np_program -> .)

    np_program                     shift and go to state 4

state 4

    (1) program -> PROGRAM ID np_program . SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty

    SEMICOLON       shift and go to state 5


state 5

    (1) program -> PROGRAM ID np_program SEMICOLON . variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty
    (2) variables -> . VARIABLES variablesU
    (3) variables -> . empty
    (89) empty -> .

    VARIABLES       shift and go to state 8
    INT             reduce using rule 89 (empty -> .)
    FLOAT           reduce using rule 89 (empty -> .)
    CHAR            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    MAIN            reduce using rule 89 (empty -> .)

    variables                      shift and go to state 6
    empty                          shift and go to state 7

state 6

    (1) program -> PROGRAM ID np_program SEMICOLON variables . functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty
    (9) functions -> . functionsU
    (10) functions -> . empty
    (11) functionsU -> . func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD
    (89) empty -> .
    (14) func_type -> . INT empty
    (15) func_type -> . FLOAT empty
    (16) func_type -> . CHAR empty
    (17) func_type -> . VOID empty

    MAIN            reduce using rule 89 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    VOID            shift and go to state 16

    functions                      shift and go to state 9
    empty                          shift and go to state 10
    functionsU                     shift and go to state 11
    func_type                      shift and go to state 12

state 7

    (3) variables -> empty .

    INT             reduce using rule 3 (variables -> empty .)
    FLOAT           reduce using rule 3 (variables -> empty .)
    CHAR            reduce using rule 3 (variables -> empty .)
    VOID            reduce using rule 3 (variables -> empty .)
    MAIN            reduce using rule 3 (variables -> empty .)
    L_BRACE         reduce using rule 3 (variables -> empty .)


state 8

    (2) variables -> VARIABLES . variablesU
    (4) variablesU -> . variablesD
    (5) variablesU -> . empty
    (6) variablesD -> . ID np_addVariableToStack COMA variablesD
    (7) variablesD -> . ID COLON var_type np_addVariable SEMICOLON variablesU
    (8) variablesD -> . ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU
    (89) empty -> .

    ID              shift and go to state 20
    INT             reduce using rule 89 (empty -> .)
    FLOAT           reduce using rule 89 (empty -> .)
    CHAR            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    MAIN            reduce using rule 89 (empty -> .)
    L_BRACE         reduce using rule 89 (empty -> .)

    variablesU                     shift and go to state 17
    variablesD                     shift and go to state 18
    empty                          shift and go to state 19

state 9

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions . MAIN np_main L_PAREN R_PAREN block np_endProgram empty

    MAIN            shift and go to state 21


state 10

    (10) functions -> empty .

    MAIN            reduce using rule 10 (functions -> empty .)


state 11

    (9) functions -> functionsU .

    MAIN            reduce using rule 9 (functions -> functionsU .)


state 12

    (11) functionsU -> func_type . FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD

    FUNCTION        shift and go to state 22


state 13

    (14) func_type -> INT . empty
    (89) empty -> .

    FUNCTION        reduce using rule 89 (empty -> .)

    empty                          shift and go to state 23

state 14

    (15) func_type -> FLOAT . empty
    (89) empty -> .

    FUNCTION        reduce using rule 89 (empty -> .)

    empty                          shift and go to state 24

state 15

    (16) func_type -> CHAR . empty
    (89) empty -> .

    FUNCTION        reduce using rule 89 (empty -> .)

    empty                          shift and go to state 25

state 16

    (17) func_type -> VOID . empty
    (89) empty -> .

    FUNCTION        reduce using rule 89 (empty -> .)

    empty                          shift and go to state 26

state 17

    (2) variables -> VARIABLES variablesU .

    INT             reduce using rule 2 (variables -> VARIABLES variablesU .)
    FLOAT           reduce using rule 2 (variables -> VARIABLES variablesU .)
    CHAR            reduce using rule 2 (variables -> VARIABLES variablesU .)
    VOID            reduce using rule 2 (variables -> VARIABLES variablesU .)
    MAIN            reduce using rule 2 (variables -> VARIABLES variablesU .)
    L_BRACE         reduce using rule 2 (variables -> VARIABLES variablesU .)


state 18

    (4) variablesU -> variablesD .

    INT             reduce using rule 4 (variablesU -> variablesD .)
    FLOAT           reduce using rule 4 (variablesU -> variablesD .)
    CHAR            reduce using rule 4 (variablesU -> variablesD .)
    VOID            reduce using rule 4 (variablesU -> variablesD .)
    MAIN            reduce using rule 4 (variablesU -> variablesD .)
    L_BRACE         reduce using rule 4 (variablesU -> variablesD .)


state 19

    (5) variablesU -> empty .

    INT             reduce using rule 5 (variablesU -> empty .)
    FLOAT           reduce using rule 5 (variablesU -> empty .)
    CHAR            reduce using rule 5 (variablesU -> empty .)
    VOID            reduce using rule 5 (variablesU -> empty .)
    MAIN            reduce using rule 5 (variablesU -> empty .)
    L_BRACE         reduce using rule 5 (variablesU -> empty .)


state 20

    (6) variablesD -> ID . np_addVariableToStack COMA variablesD
    (7) variablesD -> ID . COLON var_type np_addVariable SEMICOLON variablesU
    (8) variablesD -> ID . L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU
    (96) np_addVariableToStack -> .

    COLON           shift and go to state 28
    L_BRACKET       shift and go to state 29
    COMA            reduce using rule 96 (np_addVariableToStack -> .)

    np_addVariableToStack          shift and go to state 27

state 21

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions MAIN . np_main L_PAREN R_PAREN block np_endProgram empty
    (94) np_main -> .

    L_PAREN         reduce using rule 94 (np_main -> .)

    np_main                        shift and go to state 30

state 22

    (11) functionsU -> func_type FUNCTION . ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD

    ID              shift and go to state 31


state 23

    (14) func_type -> INT empty .

    FUNCTION        reduce using rule 14 (func_type -> INT empty .)


state 24

    (15) func_type -> FLOAT empty .

    FUNCTION        reduce using rule 15 (func_type -> FLOAT empty .)


state 25

    (16) func_type -> CHAR empty .

    FUNCTION        reduce using rule 16 (func_type -> CHAR empty .)


state 26

    (17) func_type -> VOID empty .

    FUNCTION        reduce using rule 17 (func_type -> VOID empty .)


state 27

    (6) variablesD -> ID np_addVariableToStack . COMA variablesD

    COMA            shift and go to state 32


state 28

    (7) variablesD -> ID COLON . var_type np_addVariable SEMICOLON variablesU
    (18) var_type -> . INT empty
    (19) var_type -> . FLOAT empty
    (20) var_type -> . CHAR empty

    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    CHAR            shift and go to state 36

    var_type                       shift and go to state 33

state 29

    (8) variablesD -> ID L_BRACKET . INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU

    INTVAL          shift and go to state 37


state 30

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main . L_PAREN R_PAREN block np_endProgram empty

    L_PAREN         shift and go to state 38


state 31

    (11) functionsU -> func_type FUNCTION ID . np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD
    (92) np_addFunction -> .

    L_PAREN         reduce using rule 92 (np_addFunction -> .)

    np_addFunction                 shift and go to state 39

state 32

    (6) variablesD -> ID np_addVariableToStack COMA . variablesD
    (6) variablesD -> . ID np_addVariableToStack COMA variablesD
    (7) variablesD -> . ID COLON var_type np_addVariable SEMICOLON variablesU
    (8) variablesD -> . ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU

    ID              shift and go to state 20

    variablesD                     shift and go to state 40

state 33

    (7) variablesD -> ID COLON var_type . np_addVariable SEMICOLON variablesU
    (95) np_addVariable -> .

    SEMICOLON       reduce using rule 95 (np_addVariable -> .)

    np_addVariable                 shift and go to state 41

state 34

    (18) var_type -> INT . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 42

state 35

    (19) var_type -> FLOAT . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 43

state 36

    (20) var_type -> CHAR . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 44

state 37

    (8) variablesD -> ID L_BRACKET INTVAL . R_BRACKET COLON var_type np_addArray SEMICOLON variablesU

    R_BRACKET       shift and go to state 45


state 38

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN . R_PAREN block np_endProgram empty

    R_PAREN         shift and go to state 46


state 39

    (11) functionsU -> func_type FUNCTION ID np_addFunction . L_PAREN receive_params R_PAREN variables block np_endFunction functionsD

    L_PAREN         shift and go to state 47


state 40

    (6) variablesD -> ID np_addVariableToStack COMA variablesD .

    INT             reduce using rule 6 (variablesD -> ID np_addVariableToStack COMA variablesD .)
    FLOAT           reduce using rule 6 (variablesD -> ID np_addVariableToStack COMA variablesD .)
    CHAR            reduce using rule 6 (variablesD -> ID np_addVariableToStack COMA variablesD .)
    VOID            reduce using rule 6 (variablesD -> ID np_addVariableToStack COMA variablesD .)
    MAIN            reduce using rule 6 (variablesD -> ID np_addVariableToStack COMA variablesD .)
    L_BRACE         reduce using rule 6 (variablesD -> ID np_addVariableToStack COMA variablesD .)


state 41

    (7) variablesD -> ID COLON var_type np_addVariable . SEMICOLON variablesU

    SEMICOLON       shift and go to state 48


state 42

    (18) var_type -> INT empty .

    SEMICOLON       reduce using rule 18 (var_type -> INT empty .)
    COMA            reduce using rule 18 (var_type -> INT empty .)
    R_PAREN         reduce using rule 18 (var_type -> INT empty .)


state 43

    (19) var_type -> FLOAT empty .

    SEMICOLON       reduce using rule 19 (var_type -> FLOAT empty .)
    COMA            reduce using rule 19 (var_type -> FLOAT empty .)
    R_PAREN         reduce using rule 19 (var_type -> FLOAT empty .)


state 44

    (20) var_type -> CHAR empty .

    SEMICOLON       reduce using rule 20 (var_type -> CHAR empty .)
    COMA            reduce using rule 20 (var_type -> CHAR empty .)
    R_PAREN         reduce using rule 20 (var_type -> CHAR empty .)


state 45

    (8) variablesD -> ID L_BRACKET INTVAL R_BRACKET . COLON var_type np_addArray SEMICOLON variablesU

    COLON           shift and go to state 49


state 46

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN . block np_endProgram empty
    (29) block -> . L_BRACE blockU R_BRACE empty

    L_BRACE         shift and go to state 51

    block                          shift and go to state 50

state 47

    (11) functionsU -> func_type FUNCTION ID np_addFunction L_PAREN . receive_params R_PAREN variables block np_endFunction functionsD
    (21) receive_params -> . ID COLON var_type np_receiveParams receive_paramsD empty
    (22) receive_params -> . empty
    (89) empty -> .

    ID              shift and go to state 52
    R_PAREN         reduce using rule 89 (empty -> .)

    receive_params                 shift and go to state 53
    empty                          shift and go to state 54

state 48

    (7) variablesD -> ID COLON var_type np_addVariable SEMICOLON . variablesU
    (4) variablesU -> . variablesD
    (5) variablesU -> . empty
    (6) variablesD -> . ID np_addVariableToStack COMA variablesD
    (7) variablesD -> . ID COLON var_type np_addVariable SEMICOLON variablesU
    (8) variablesD -> . ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU
    (89) empty -> .

    ID              shift and go to state 20
    INT             reduce using rule 89 (empty -> .)
    FLOAT           reduce using rule 89 (empty -> .)
    CHAR            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    MAIN            reduce using rule 89 (empty -> .)
    L_BRACE         reduce using rule 89 (empty -> .)

    variablesU                     shift and go to state 55
    variablesD                     shift and go to state 18
    empty                          shift and go to state 19

state 49

    (8) variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON . var_type np_addArray SEMICOLON variablesU
    (18) var_type -> . INT empty
    (19) var_type -> . FLOAT empty
    (20) var_type -> . CHAR empty

    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    CHAR            shift and go to state 36

    var_type                       shift and go to state 56

state 50

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block . np_endProgram empty
    (91) np_endProgram -> .

    $end            reduce using rule 91 (np_endProgram -> .)

    np_endProgram                  shift and go to state 57

state 51

    (29) block -> L_BRACE . blockU R_BRACE empty
    (30) blockU -> . statement blockD np_emptyStacks empty
    (31) blockU -> . empty
    (34) statement -> . assignment SEMICOLON empty
    (35) statement -> . call np_isStatement SEMICOLON empty
    (36) statement -> . return SEMICOLON empty
    (37) statement -> . read SEMICOLON empty
    (38) statement -> . write SEMICOLON empty
    (39) statement -> . decision empty
    (40) statement -> . conditional empty
    (41) statement -> . non_conditional empty
    (42) statement -> . empty
    (89) empty -> .
    (43) assignment -> . ID np_addID EQUAL np_addOperator hyper_exp np_assignment empty
    (44) assignment -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty
    (46) return -> . RETURN L_PAREN hyper_exp np_return R_PAREN empty
    (47) read -> . READ L_PAREN ID np_read R_PAREN empty
    (48) write -> . WRITE L_PAREN writeD R_PAREN empty
    (51) decision -> . IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty
    (54) conditional -> . WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty
    (55) non_conditional -> . FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FROM resolved as shift
    R_BRACE         reduce using rule 89 (empty -> .)
    ID              shift and go to state 69
    RETURN          shift and go to state 70
    READ            shift and go to state 71
    WRITE           shift and go to state 72
    IF              shift and go to state 73
    WHILE           shift and go to state 74
    FROM            shift and go to state 75

  ! ID              [ reduce using rule 89 (empty -> .) ]
  ! RETURN          [ reduce using rule 89 (empty -> .) ]
  ! READ            [ reduce using rule 89 (empty -> .) ]
  ! WRITE           [ reduce using rule 89 (empty -> .) ]
  ! IF              [ reduce using rule 89 (empty -> .) ]
  ! WHILE           [ reduce using rule 89 (empty -> .) ]
  ! FROM            [ reduce using rule 89 (empty -> .) ]

    blockU                         shift and go to state 58
    empty                          shift and go to state 59
    statement                      shift and go to state 60
    assignment                     shift and go to state 61
    call                           shift and go to state 62
    return                         shift and go to state 63
    read                           shift and go to state 64
    write                          shift and go to state 65
    decision                       shift and go to state 66
    conditional                    shift and go to state 67
    non_conditional                shift and go to state 68

state 52

    (21) receive_params -> ID . COLON var_type np_receiveParams receive_paramsD empty

    COLON           shift and go to state 76


state 53

    (11) functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params . R_PAREN variables block np_endFunction functionsD

    R_PAREN         shift and go to state 77


state 54

    (22) receive_params -> empty .

    R_PAREN         reduce using rule 22 (receive_params -> empty .)


state 55

    (7) variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU .

    INT             reduce using rule 7 (variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU .)
    FLOAT           reduce using rule 7 (variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU .)
    CHAR            reduce using rule 7 (variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU .)
    VOID            reduce using rule 7 (variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU .)
    MAIN            reduce using rule 7 (variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU .)
    L_BRACE         reduce using rule 7 (variablesD -> ID COLON var_type np_addVariable SEMICOLON variablesU .)


state 56

    (8) variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type . np_addArray SEMICOLON variablesU
    (97) np_addArray -> .

    SEMICOLON       reduce using rule 97 (np_addArray -> .)

    np_addArray                    shift and go to state 78

state 57

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram . empty
    (89) empty -> .

    $end            reduce using rule 89 (empty -> .)

    empty                          shift and go to state 79

state 58

    (29) block -> L_BRACE blockU . R_BRACE empty

    R_BRACE         shift and go to state 80


state 59

    (31) blockU -> empty .
    (42) statement -> empty .

  ! reduce/reduce conflict for R_BRACE resolved using rule 31 (blockU -> empty .)
    R_BRACE         reduce using rule 31 (blockU -> empty .)
    ID              reduce using rule 42 (statement -> empty .)
    RETURN          reduce using rule 42 (statement -> empty .)
    READ            reduce using rule 42 (statement -> empty .)
    WRITE           reduce using rule 42 (statement -> empty .)
    IF              reduce using rule 42 (statement -> empty .)
    WHILE           reduce using rule 42 (statement -> empty .)
    FROM            reduce using rule 42 (statement -> empty .)

  ! R_BRACE         [ reduce using rule 42 (statement -> empty .) ]


state 60

    (30) blockU -> statement . blockD np_emptyStacks empty
    (32) blockD -> . blockU empty
    (33) blockD -> . empty
    (30) blockU -> . statement blockD np_emptyStacks empty
    (31) blockU -> . empty
    (89) empty -> .
    (34) statement -> . assignment SEMICOLON empty
    (35) statement -> . call np_isStatement SEMICOLON empty
    (36) statement -> . return SEMICOLON empty
    (37) statement -> . read SEMICOLON empty
    (38) statement -> . write SEMICOLON empty
    (39) statement -> . decision empty
    (40) statement -> . conditional empty
    (41) statement -> . non_conditional empty
    (42) statement -> . empty
    (43) assignment -> . ID np_addID EQUAL np_addOperator hyper_exp np_assignment empty
    (44) assignment -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty
    (46) return -> . RETURN L_PAREN hyper_exp np_return R_PAREN empty
    (47) read -> . READ L_PAREN ID np_read R_PAREN empty
    (48) write -> . WRITE L_PAREN writeD R_PAREN empty
    (51) decision -> . IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty
    (54) conditional -> . WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty
    (55) non_conditional -> . FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for RETURN resolved as shift
  ! shift/reduce conflict for READ resolved as shift
  ! shift/reduce conflict for WRITE resolved as shift
  ! shift/reduce conflict for IF resolved as shift
  ! shift/reduce conflict for WHILE resolved as shift
  ! shift/reduce conflict for FROM resolved as shift
    R_BRACE         reduce using rule 89 (empty -> .)
    ID              shift and go to state 69
    RETURN          shift and go to state 70
    READ            shift and go to state 71
    WRITE           shift and go to state 72
    IF              shift and go to state 73
    WHILE           shift and go to state 74
    FROM            shift and go to state 75

  ! ID              [ reduce using rule 89 (empty -> .) ]
  ! RETURN          [ reduce using rule 89 (empty -> .) ]
  ! READ            [ reduce using rule 89 (empty -> .) ]
  ! WRITE           [ reduce using rule 89 (empty -> .) ]
  ! IF              [ reduce using rule 89 (empty -> .) ]
  ! WHILE           [ reduce using rule 89 (empty -> .) ]
  ! FROM            [ reduce using rule 89 (empty -> .) ]

    statement                      shift and go to state 60
    blockD                         shift and go to state 81
    empty                          shift and go to state 82
    blockU                         shift and go to state 83
    assignment                     shift and go to state 61
    call                           shift and go to state 62
    return                         shift and go to state 63
    read                           shift and go to state 64
    write                          shift and go to state 65
    decision                       shift and go to state 66
    conditional                    shift and go to state 67
    non_conditional                shift and go to state 68

state 61

    (34) statement -> assignment . SEMICOLON empty

    SEMICOLON       shift and go to state 84


state 62

    (35) statement -> call . np_isStatement SEMICOLON empty
    (106) np_isStatement -> .

    SEMICOLON       reduce using rule 106 (np_isStatement -> .)

    np_isStatement                 shift and go to state 85

state 63

    (36) statement -> return . SEMICOLON empty

    SEMICOLON       shift and go to state 86


state 64

    (37) statement -> read . SEMICOLON empty

    SEMICOLON       shift and go to state 87


state 65

    (38) statement -> write . SEMICOLON empty

    SEMICOLON       shift and go to state 88


state 66

    (39) statement -> decision . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 89

state 67

    (40) statement -> conditional . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 90

state 68

    (41) statement -> non_conditional . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 91

state 69

    (43) assignment -> ID . np_addID EQUAL np_addOperator hyper_exp np_assignment empty
    (44) assignment -> ID . L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty
    (45) call -> ID . np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty
    (98) np_addID -> .
    (104) np_call_era -> .

    L_BRACKET       shift and go to state 93
    EQUAL           reduce using rule 98 (np_addID -> .)
    L_PAREN         reduce using rule 104 (np_call_era -> .)

    np_addID                       shift and go to state 92
    np_call_era                    shift and go to state 94

state 70

    (46) return -> RETURN . L_PAREN hyper_exp np_return R_PAREN empty

    L_PAREN         shift and go to state 95


state 71

    (47) read -> READ . L_PAREN ID np_read R_PAREN empty

    L_PAREN         shift and go to state 96


state 72

    (48) write -> WRITE . L_PAREN writeD R_PAREN empty

    L_PAREN         shift and go to state 97


state 73

    (51) decision -> IF . L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty

    L_PAREN         shift and go to state 98


state 74

    (54) conditional -> WHILE . L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty

    L_PAREN         shift and go to state 99


state 75

    (55) non_conditional -> FROM . L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty

    L_PAREN         shift and go to state 100


state 76

    (21) receive_params -> ID COLON . var_type np_receiveParams receive_paramsD empty
    (18) var_type -> . INT empty
    (19) var_type -> . FLOAT empty
    (20) var_type -> . CHAR empty

    INT             shift and go to state 34
    FLOAT           shift and go to state 35
    CHAR            shift and go to state 36

    var_type                       shift and go to state 101

state 77

    (11) functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN . variables block np_endFunction functionsD
    (2) variables -> . VARIABLES variablesU
    (3) variables -> . empty
    (89) empty -> .

    VARIABLES       shift and go to state 8
    L_BRACE         reduce using rule 89 (empty -> .)

    variables                      shift and go to state 102
    empty                          shift and go to state 7

state 78

    (8) variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray . SEMICOLON variablesU

    SEMICOLON       shift and go to state 103


state 79

    (1) program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty .

    $end            reduce using rule 1 (program -> PROGRAM ID np_program SEMICOLON variables functions MAIN np_main L_PAREN R_PAREN block np_endProgram empty .)


state 80

    (29) block -> L_BRACE blockU R_BRACE . empty
    (89) empty -> .

    $end            reduce using rule 89 (empty -> .)
    INT             reduce using rule 89 (empty -> .)
    FLOAT           reduce using rule 89 (empty -> .)
    CHAR            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    MAIN            reduce using rule 89 (empty -> .)
    ELSE            reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 104

state 81

    (30) blockU -> statement blockD . np_emptyStacks empty
    (131) np_emptyStacks -> .

    R_BRACE         reduce using rule 131 (np_emptyStacks -> .)

    np_emptyStacks                 shift and go to state 105

state 82

    (33) blockD -> empty .
    (31) blockU -> empty .
    (42) statement -> empty .

  ! reduce/reduce conflict for R_BRACE resolved using rule 31 (blockU -> empty .)
  ! reduce/reduce conflict for R_BRACE resolved using rule 31 (blockU -> empty .)
    R_BRACE         reduce using rule 31 (blockU -> empty .)
    ID              reduce using rule 42 (statement -> empty .)
    RETURN          reduce using rule 42 (statement -> empty .)
    READ            reduce using rule 42 (statement -> empty .)
    WRITE           reduce using rule 42 (statement -> empty .)
    IF              reduce using rule 42 (statement -> empty .)
    WHILE           reduce using rule 42 (statement -> empty .)
    FROM            reduce using rule 42 (statement -> empty .)

  ! R_BRACE         [ reduce using rule 33 (blockD -> empty .) ]
  ! R_BRACE         [ reduce using rule 42 (statement -> empty .) ]


state 83

    (32) blockD -> blockU . empty
    (89) empty -> .

    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 106

state 84

    (34) statement -> assignment SEMICOLON . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 107

state 85

    (35) statement -> call np_isStatement . SEMICOLON empty

    SEMICOLON       shift and go to state 108


state 86

    (36) statement -> return SEMICOLON . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 109

state 87

    (37) statement -> read SEMICOLON . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 110

state 88

    (38) statement -> write SEMICOLON . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 111

state 89

    (39) statement -> decision empty .

    ID              reduce using rule 39 (statement -> decision empty .)
    RETURN          reduce using rule 39 (statement -> decision empty .)
    READ            reduce using rule 39 (statement -> decision empty .)
    WRITE           reduce using rule 39 (statement -> decision empty .)
    IF              reduce using rule 39 (statement -> decision empty .)
    WHILE           reduce using rule 39 (statement -> decision empty .)
    FROM            reduce using rule 39 (statement -> decision empty .)
    R_BRACE         reduce using rule 39 (statement -> decision empty .)


state 90

    (40) statement -> conditional empty .

    ID              reduce using rule 40 (statement -> conditional empty .)
    RETURN          reduce using rule 40 (statement -> conditional empty .)
    READ            reduce using rule 40 (statement -> conditional empty .)
    WRITE           reduce using rule 40 (statement -> conditional empty .)
    IF              reduce using rule 40 (statement -> conditional empty .)
    WHILE           reduce using rule 40 (statement -> conditional empty .)
    FROM            reduce using rule 40 (statement -> conditional empty .)
    R_BRACE         reduce using rule 40 (statement -> conditional empty .)


state 91

    (41) statement -> non_conditional empty .

    ID              reduce using rule 41 (statement -> non_conditional empty .)
    RETURN          reduce using rule 41 (statement -> non_conditional empty .)
    READ            reduce using rule 41 (statement -> non_conditional empty .)
    WRITE           reduce using rule 41 (statement -> non_conditional empty .)
    IF              reduce using rule 41 (statement -> non_conditional empty .)
    WHILE           reduce using rule 41 (statement -> non_conditional empty .)
    FROM            reduce using rule 41 (statement -> non_conditional empty .)
    R_BRACE         reduce using rule 41 (statement -> non_conditional empty .)


state 92

    (43) assignment -> ID np_addID . EQUAL np_addOperator hyper_exp np_assignment empty

    EQUAL           shift and go to state 112


state 93

    (44) assignment -> ID L_BRACKET . np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty
    (99) np_fakeBottom -> .

    L_PAREN         reduce using rule 99 (np_fakeBottom -> .)
    ID              reduce using rule 99 (np_fakeBottom -> .)
    INTVAL          reduce using rule 99 (np_fakeBottom -> .)
    FLOATVAL        reduce using rule 99 (np_fakeBottom -> .)
    CHARVAL         reduce using rule 99 (np_fakeBottom -> .)

    np_fakeBottom                  shift and go to state 113

state 94

    (45) call -> ID np_call_era . L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 114


state 95

    (46) return -> RETURN L_PAREN . hyper_exp np_return R_PAREN empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 116
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 96

    (47) read -> READ L_PAREN . ID np_read R_PAREN empty

    ID              shift and go to state 127


state 97

    (48) write -> WRITE L_PAREN . writeD R_PAREN empty
    (49) writeD -> . hyper_exp np_write empty
    (50) writeD -> . STRING np_string empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    STRING          shift and go to state 130
    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    writeD                         shift and go to state 128
    hyper_exp                      shift and go to state 129
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 98

    (51) decision -> IF L_PAREN . hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 131
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 99

    (54) conditional -> WHILE L_PAREN . np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty
    (121) np_conditionalBefore -> .

    L_PAREN         reduce using rule 121 (np_conditionalBefore -> .)
    ID              reduce using rule 121 (np_conditionalBefore -> .)
    INTVAL          reduce using rule 121 (np_conditionalBefore -> .)
    FLOATVAL        reduce using rule 121 (np_conditionalBefore -> .)
    CHARVAL         reduce using rule 121 (np_conditionalBefore -> .)

    np_conditionalBefore           shift and go to state 132

state 100

    (55) non_conditional -> FROM L_PAREN . for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty
    (56) for_assignment -> . ID np_addIDFor EQUAL np_addOperator hyper_exp np_for_assignment empty

    ID              shift and go to state 134

    for_assignment                 shift and go to state 133

state 101

    (21) receive_params -> ID COLON var_type . np_receiveParams receive_paramsD empty
    (129) np_receiveParams -> .

    COMA            reduce using rule 129 (np_receiveParams -> .)
    R_PAREN         reduce using rule 129 (np_receiveParams -> .)

    np_receiveParams               shift and go to state 135

state 102

    (11) functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables . block np_endFunction functionsD
    (29) block -> . L_BRACE blockU R_BRACE empty

    L_BRACE         shift and go to state 51

    block                          shift and go to state 136

state 103

    (8) variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON . variablesU
    (4) variablesU -> . variablesD
    (5) variablesU -> . empty
    (6) variablesD -> . ID np_addVariableToStack COMA variablesD
    (7) variablesD -> . ID COLON var_type np_addVariable SEMICOLON variablesU
    (8) variablesD -> . ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU
    (89) empty -> .

    ID              shift and go to state 20
    INT             reduce using rule 89 (empty -> .)
    FLOAT           reduce using rule 89 (empty -> .)
    CHAR            reduce using rule 89 (empty -> .)
    VOID            reduce using rule 89 (empty -> .)
    MAIN            reduce using rule 89 (empty -> .)
    L_BRACE         reduce using rule 89 (empty -> .)

    variablesU                     shift and go to state 137
    variablesD                     shift and go to state 18
    empty                          shift and go to state 19

state 104

    (29) block -> L_BRACE blockU R_BRACE empty .

    $end            reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    INT             reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    FLOAT           reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    CHAR            reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    VOID            reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    MAIN            reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    ELSE            reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    ID              reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    RETURN          reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    READ            reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    WRITE           reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    IF              reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    WHILE           reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    FROM            reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)
    R_BRACE         reduce using rule 29 (block -> L_BRACE blockU R_BRACE empty .)


state 105

    (30) blockU -> statement blockD np_emptyStacks . empty
    (89) empty -> .

    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 138

state 106

    (32) blockD -> blockU empty .

    R_BRACE         reduce using rule 32 (blockD -> blockU empty .)


state 107

    (34) statement -> assignment SEMICOLON empty .

    ID              reduce using rule 34 (statement -> assignment SEMICOLON empty .)
    RETURN          reduce using rule 34 (statement -> assignment SEMICOLON empty .)
    READ            reduce using rule 34 (statement -> assignment SEMICOLON empty .)
    WRITE           reduce using rule 34 (statement -> assignment SEMICOLON empty .)
    IF              reduce using rule 34 (statement -> assignment SEMICOLON empty .)
    WHILE           reduce using rule 34 (statement -> assignment SEMICOLON empty .)
    FROM            reduce using rule 34 (statement -> assignment SEMICOLON empty .)
    R_BRACE         reduce using rule 34 (statement -> assignment SEMICOLON empty .)


state 108

    (35) statement -> call np_isStatement SEMICOLON . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 139

state 109

    (36) statement -> return SEMICOLON empty .

    ID              reduce using rule 36 (statement -> return SEMICOLON empty .)
    RETURN          reduce using rule 36 (statement -> return SEMICOLON empty .)
    READ            reduce using rule 36 (statement -> return SEMICOLON empty .)
    WRITE           reduce using rule 36 (statement -> return SEMICOLON empty .)
    IF              reduce using rule 36 (statement -> return SEMICOLON empty .)
    WHILE           reduce using rule 36 (statement -> return SEMICOLON empty .)
    FROM            reduce using rule 36 (statement -> return SEMICOLON empty .)
    R_BRACE         reduce using rule 36 (statement -> return SEMICOLON empty .)


state 110

    (37) statement -> read SEMICOLON empty .

    ID              reduce using rule 37 (statement -> read SEMICOLON empty .)
    RETURN          reduce using rule 37 (statement -> read SEMICOLON empty .)
    READ            reduce using rule 37 (statement -> read SEMICOLON empty .)
    WRITE           reduce using rule 37 (statement -> read SEMICOLON empty .)
    IF              reduce using rule 37 (statement -> read SEMICOLON empty .)
    WHILE           reduce using rule 37 (statement -> read SEMICOLON empty .)
    FROM            reduce using rule 37 (statement -> read SEMICOLON empty .)
    R_BRACE         reduce using rule 37 (statement -> read SEMICOLON empty .)


state 111

    (38) statement -> write SEMICOLON empty .

    ID              reduce using rule 38 (statement -> write SEMICOLON empty .)
    RETURN          reduce using rule 38 (statement -> write SEMICOLON empty .)
    READ            reduce using rule 38 (statement -> write SEMICOLON empty .)
    WRITE           reduce using rule 38 (statement -> write SEMICOLON empty .)
    IF              reduce using rule 38 (statement -> write SEMICOLON empty .)
    WHILE           reduce using rule 38 (statement -> write SEMICOLON empty .)
    FROM            reduce using rule 38 (statement -> write SEMICOLON empty .)
    R_BRACE         reduce using rule 38 (statement -> write SEMICOLON empty .)


state 112

    (43) assignment -> ID np_addID EQUAL . np_addOperator hyper_exp np_assignment empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 140

state 113

    (44) assignment -> ID L_BRACKET np_fakeBottom . hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 141
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 114

    (45) call -> ID np_call_era L_PAREN . send_params np_paramValidation R_PAREN np_call_gosub empty
    (25) send_params -> . hyper_exp np_sentParam send_paramsD empty
    (26) send_params -> . empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (89) empty -> .
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    R_PAREN         reduce using rule 89 (empty -> .)
    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    send_params                    shift and go to state 142
    empty                          shift and go to state 143
    hyper_exp                      shift and go to state 144
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 115

    (83) factor -> L_PAREN . hyper_exp R_PAREN empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 145
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 116

    (46) return -> RETURN L_PAREN hyper_exp . np_return R_PAREN empty
    (117) np_return -> .

    R_PAREN         reduce using rule 117 (np_return -> .)

    np_return                      shift and go to state 146

state 117

    (69) hyper_exp -> super_exp . np_doHyperExp hyper_expU
    (112) np_doHyperExp -> .

    OR              reduce using rule 112 (np_doHyperExp -> .)
    AND             reduce using rule 112 (np_doHyperExp -> .)
    R_PAREN         reduce using rule 112 (np_doHyperExp -> .)
    R_BRACKET       reduce using rule 112 (np_doHyperExp -> .)
    COMA            reduce using rule 112 (np_doHyperExp -> .)
    SEMICOLON       reduce using rule 112 (np_doHyperExp -> .)
    DO              reduce using rule 112 (np_doHyperExp -> .)

    np_doHyperExp                  shift and go to state 147

state 118

    (72) super_exp -> exp . np_doSuperExp super_expU
    (111) np_doSuperExp -> .

    LESS            reduce using rule 111 (np_doSuperExp -> .)
    GREATER         reduce using rule 111 (np_doSuperExp -> .)
    LESSEQUAL       reduce using rule 111 (np_doSuperExp -> .)
    GREATEREQUAL    reduce using rule 111 (np_doSuperExp -> .)
    EQUALTO         reduce using rule 111 (np_doSuperExp -> .)
    DIFF            reduce using rule 111 (np_doSuperExp -> .)
    OR              reduce using rule 111 (np_doSuperExp -> .)
    AND             reduce using rule 111 (np_doSuperExp -> .)
    R_PAREN         reduce using rule 111 (np_doSuperExp -> .)
    R_BRACKET       reduce using rule 111 (np_doSuperExp -> .)
    COMA            reduce using rule 111 (np_doSuperExp -> .)
    SEMICOLON       reduce using rule 111 (np_doSuperExp -> .)
    DO              reduce using rule 111 (np_doSuperExp -> .)

    np_doSuperExp                  shift and go to state 148

state 119

    (75) exp -> term . np_doExp expU
    (110) np_doExp -> .

    PLUS            reduce using rule 110 (np_doExp -> .)
    MINUS           reduce using rule 110 (np_doExp -> .)
    LESS            reduce using rule 110 (np_doExp -> .)
    GREATER         reduce using rule 110 (np_doExp -> .)
    LESSEQUAL       reduce using rule 110 (np_doExp -> .)
    GREATEREQUAL    reduce using rule 110 (np_doExp -> .)
    EQUALTO         reduce using rule 110 (np_doExp -> .)
    DIFF            reduce using rule 110 (np_doExp -> .)
    OR              reduce using rule 110 (np_doExp -> .)
    AND             reduce using rule 110 (np_doExp -> .)
    R_PAREN         reduce using rule 110 (np_doExp -> .)
    R_BRACKET       reduce using rule 110 (np_doExp -> .)
    COMA            reduce using rule 110 (np_doExp -> .)
    SEMICOLON       reduce using rule 110 (np_doExp -> .)
    DO              reduce using rule 110 (np_doExp -> .)

    np_doExp                       shift and go to state 149

state 120

    (78) term -> factor . np_doTerm termU
    (109) np_doTerm -> .

    MULT            reduce using rule 109 (np_doTerm -> .)
    DIV             reduce using rule 109 (np_doTerm -> .)
    PLUS            reduce using rule 109 (np_doTerm -> .)
    MINUS           reduce using rule 109 (np_doTerm -> .)
    LESS            reduce using rule 109 (np_doTerm -> .)
    GREATER         reduce using rule 109 (np_doTerm -> .)
    LESSEQUAL       reduce using rule 109 (np_doTerm -> .)
    GREATEREQUAL    reduce using rule 109 (np_doTerm -> .)
    EQUALTO         reduce using rule 109 (np_doTerm -> .)
    DIFF            reduce using rule 109 (np_doTerm -> .)
    OR              reduce using rule 109 (np_doTerm -> .)
    AND             reduce using rule 109 (np_doTerm -> .)
    R_PAREN         reduce using rule 109 (np_doTerm -> .)
    R_BRACKET       reduce using rule 109 (np_doTerm -> .)
    COMA            reduce using rule 109 (np_doTerm -> .)
    SEMICOLON       reduce using rule 109 (np_doTerm -> .)
    DO              reduce using rule 109 (np_doTerm -> .)

    np_doTerm                      shift and go to state 150

state 121

    (81) factor -> varcte . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 151

state 122

    (82) factor -> call . np_isExpression empty
    (107) np_isExpression -> .

    MULT            reduce using rule 107 (np_isExpression -> .)
    DIV             reduce using rule 107 (np_isExpression -> .)
    PLUS            reduce using rule 107 (np_isExpression -> .)
    MINUS           reduce using rule 107 (np_isExpression -> .)
    LESS            reduce using rule 107 (np_isExpression -> .)
    GREATER         reduce using rule 107 (np_isExpression -> .)
    LESSEQUAL       reduce using rule 107 (np_isExpression -> .)
    GREATEREQUAL    reduce using rule 107 (np_isExpression -> .)
    EQUALTO         reduce using rule 107 (np_isExpression -> .)
    DIFF            reduce using rule 107 (np_isExpression -> .)
    OR              reduce using rule 107 (np_isExpression -> .)
    AND             reduce using rule 107 (np_isExpression -> .)
    R_PAREN         reduce using rule 107 (np_isExpression -> .)
    R_BRACKET       reduce using rule 107 (np_isExpression -> .)
    COMA            reduce using rule 107 (np_isExpression -> .)
    SEMICOLON       reduce using rule 107 (np_isExpression -> .)
    DO              reduce using rule 107 (np_isExpression -> .)

    np_isExpression                shift and go to state 152

state 123

    (84) varcte -> ID . np_addID empty
    (85) varcte -> ID . L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (45) call -> ID . np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty
    (98) np_addID -> .
    (104) np_call_era -> .

    L_BRACKET       shift and go to state 154
    MULT            reduce using rule 98 (np_addID -> .)
    DIV             reduce using rule 98 (np_addID -> .)
    PLUS            reduce using rule 98 (np_addID -> .)
    MINUS           reduce using rule 98 (np_addID -> .)
    LESS            reduce using rule 98 (np_addID -> .)
    GREATER         reduce using rule 98 (np_addID -> .)
    LESSEQUAL       reduce using rule 98 (np_addID -> .)
    GREATEREQUAL    reduce using rule 98 (np_addID -> .)
    EQUALTO         reduce using rule 98 (np_addID -> .)
    DIFF            reduce using rule 98 (np_addID -> .)
    OR              reduce using rule 98 (np_addID -> .)
    AND             reduce using rule 98 (np_addID -> .)
    R_PAREN         reduce using rule 98 (np_addID -> .)
    R_BRACKET       reduce using rule 98 (np_addID -> .)
    COMA            reduce using rule 98 (np_addID -> .)
    SEMICOLON       reduce using rule 98 (np_addID -> .)
    DO              reduce using rule 98 (np_addID -> .)
    L_PAREN         reduce using rule 104 (np_call_era -> .)

    np_addID                       shift and go to state 153
    np_call_era                    shift and go to state 94

state 124

    (86) varcte -> INTVAL . np_addConstInt empty
    (101) np_addConstInt -> .

    MULT            reduce using rule 101 (np_addConstInt -> .)
    DIV             reduce using rule 101 (np_addConstInt -> .)
    PLUS            reduce using rule 101 (np_addConstInt -> .)
    MINUS           reduce using rule 101 (np_addConstInt -> .)
    LESS            reduce using rule 101 (np_addConstInt -> .)
    GREATER         reduce using rule 101 (np_addConstInt -> .)
    LESSEQUAL       reduce using rule 101 (np_addConstInt -> .)
    GREATEREQUAL    reduce using rule 101 (np_addConstInt -> .)
    EQUALTO         reduce using rule 101 (np_addConstInt -> .)
    DIFF            reduce using rule 101 (np_addConstInt -> .)
    OR              reduce using rule 101 (np_addConstInt -> .)
    AND             reduce using rule 101 (np_addConstInt -> .)
    R_PAREN         reduce using rule 101 (np_addConstInt -> .)
    R_BRACKET       reduce using rule 101 (np_addConstInt -> .)
    COMA            reduce using rule 101 (np_addConstInt -> .)
    SEMICOLON       reduce using rule 101 (np_addConstInt -> .)
    DO              reduce using rule 101 (np_addConstInt -> .)

    np_addConstInt                 shift and go to state 155

state 125

    (87) varcte -> FLOATVAL . np_addConstFloat empty
    (102) np_addConstFloat -> .

    MULT            reduce using rule 102 (np_addConstFloat -> .)
    DIV             reduce using rule 102 (np_addConstFloat -> .)
    PLUS            reduce using rule 102 (np_addConstFloat -> .)
    MINUS           reduce using rule 102 (np_addConstFloat -> .)
    LESS            reduce using rule 102 (np_addConstFloat -> .)
    GREATER         reduce using rule 102 (np_addConstFloat -> .)
    LESSEQUAL       reduce using rule 102 (np_addConstFloat -> .)
    GREATEREQUAL    reduce using rule 102 (np_addConstFloat -> .)
    EQUALTO         reduce using rule 102 (np_addConstFloat -> .)
    DIFF            reduce using rule 102 (np_addConstFloat -> .)
    OR              reduce using rule 102 (np_addConstFloat -> .)
    AND             reduce using rule 102 (np_addConstFloat -> .)
    R_PAREN         reduce using rule 102 (np_addConstFloat -> .)
    R_BRACKET       reduce using rule 102 (np_addConstFloat -> .)
    COMA            reduce using rule 102 (np_addConstFloat -> .)
    SEMICOLON       reduce using rule 102 (np_addConstFloat -> .)
    DO              reduce using rule 102 (np_addConstFloat -> .)

    np_addConstFloat               shift and go to state 156

state 126

    (88) varcte -> CHARVAL . np_addConstChar empty
    (103) np_addConstChar -> .

    MULT            reduce using rule 103 (np_addConstChar -> .)
    DIV             reduce using rule 103 (np_addConstChar -> .)
    PLUS            reduce using rule 103 (np_addConstChar -> .)
    MINUS           reduce using rule 103 (np_addConstChar -> .)
    LESS            reduce using rule 103 (np_addConstChar -> .)
    GREATER         reduce using rule 103 (np_addConstChar -> .)
    LESSEQUAL       reduce using rule 103 (np_addConstChar -> .)
    GREATEREQUAL    reduce using rule 103 (np_addConstChar -> .)
    EQUALTO         reduce using rule 103 (np_addConstChar -> .)
    DIFF            reduce using rule 103 (np_addConstChar -> .)
    OR              reduce using rule 103 (np_addConstChar -> .)
    AND             reduce using rule 103 (np_addConstChar -> .)
    R_PAREN         reduce using rule 103 (np_addConstChar -> .)
    R_BRACKET       reduce using rule 103 (np_addConstChar -> .)
    COMA            reduce using rule 103 (np_addConstChar -> .)
    SEMICOLON       reduce using rule 103 (np_addConstChar -> .)
    DO              reduce using rule 103 (np_addConstChar -> .)

    np_addConstChar                shift and go to state 157

state 127

    (47) read -> READ L_PAREN ID . np_read R_PAREN empty
    (114) np_read -> .

    R_PAREN         reduce using rule 114 (np_read -> .)

    np_read                        shift and go to state 158

state 128

    (48) write -> WRITE L_PAREN writeD . R_PAREN empty

    R_PAREN         shift and go to state 159


state 129

    (49) writeD -> hyper_exp . np_write empty
    (115) np_write -> .

    R_PAREN         reduce using rule 115 (np_write -> .)

    np_write                       shift and go to state 160

state 130

    (50) writeD -> STRING . np_string empty
    (116) np_string -> .

    R_PAREN         reduce using rule 116 (np_string -> .)

    np_string                      shift and go to state 161

state 131

    (51) decision -> IF L_PAREN hyper_exp . R_PAREN np_startDecision THEN block decisionU np_endDecision empty

    R_PAREN         shift and go to state 162


state 132

    (54) conditional -> WHILE L_PAREN np_conditionalBefore . hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 163
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 133

    (55) non_conditional -> FROM L_PAREN for_assignment . R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty

    R_PAREN         shift and go to state 164


state 134

    (56) for_assignment -> ID . np_addIDFor EQUAL np_addOperator hyper_exp np_for_assignment empty
    (124) np_addIDFor -> .

    EQUAL           reduce using rule 124 (np_addIDFor -> .)

    np_addIDFor                    shift and go to state 165

state 135

    (21) receive_params -> ID COLON var_type np_receiveParams . receive_paramsD empty
    (23) receive_paramsD -> . COMA receive_params empty
    (24) receive_paramsD -> . empty
    (89) empty -> .

    COMA            shift and go to state 168
    R_PAREN         reduce using rule 89 (empty -> .)

    receive_paramsD                shift and go to state 166
    empty                          shift and go to state 167

state 136

    (11) functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block . np_endFunction functionsD
    (93) np_endFunction -> .

    INT             reduce using rule 93 (np_endFunction -> .)
    FLOAT           reduce using rule 93 (np_endFunction -> .)
    CHAR            reduce using rule 93 (np_endFunction -> .)
    VOID            reduce using rule 93 (np_endFunction -> .)
    MAIN            reduce using rule 93 (np_endFunction -> .)

    np_endFunction                 shift and go to state 169

state 137

    (8) variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU .

    INT             reduce using rule 8 (variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU .)
    FLOAT           reduce using rule 8 (variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU .)
    CHAR            reduce using rule 8 (variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU .)
    VOID            reduce using rule 8 (variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU .)
    MAIN            reduce using rule 8 (variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU .)
    L_BRACE         reduce using rule 8 (variablesD -> ID L_BRACKET INTVAL R_BRACKET COLON var_type np_addArray SEMICOLON variablesU .)


state 138

    (30) blockU -> statement blockD np_emptyStacks empty .

    R_BRACE         reduce using rule 30 (blockU -> statement blockD np_emptyStacks empty .)


state 139

    (35) statement -> call np_isStatement SEMICOLON empty .

    ID              reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)
    RETURN          reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)
    READ            reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)
    WRITE           reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)
    IF              reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)
    WHILE           reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)
    FROM            reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)
    R_BRACE         reduce using rule 35 (statement -> call np_isStatement SEMICOLON empty .)


state 140

    (43) assignment -> ID np_addID EQUAL np_addOperator . hyper_exp np_assignment empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 170
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 141

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp . R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty

    R_BRACKET       shift and go to state 171


state 142

    (45) call -> ID np_call_era L_PAREN send_params . np_paramValidation R_PAREN np_call_gosub empty
    (130) np_paramValidation -> .

    R_PAREN         reduce using rule 130 (np_paramValidation -> .)

    np_paramValidation             shift and go to state 172

state 143

    (26) send_params -> empty .

    R_PAREN         reduce using rule 26 (send_params -> empty .)


state 144

    (25) send_params -> hyper_exp . np_sentParam send_paramsD empty
    (128) np_sentParam -> .

    COMA            reduce using rule 128 (np_sentParam -> .)
    R_PAREN         reduce using rule 128 (np_sentParam -> .)

    np_sentParam                   shift and go to state 173

state 145

    (83) factor -> L_PAREN hyper_exp . R_PAREN empty

    R_PAREN         shift and go to state 174


state 146

    (46) return -> RETURN L_PAREN hyper_exp np_return . R_PAREN empty

    R_PAREN         shift and go to state 175


state 147

    (69) hyper_exp -> super_exp np_doHyperExp . hyper_expU
    (70) hyper_expU -> . operatorL hyper_exp empty
    (71) hyper_expU -> . empty
    (61) operatorL -> . OR np_addOperator empty
    (62) operatorL -> . AND np_addOperator empty
    (89) empty -> .

    OR              shift and go to state 179
    AND             shift and go to state 180
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    hyper_expU                     shift and go to state 176
    operatorL                      shift and go to state 177
    empty                          shift and go to state 178

state 148

    (72) super_exp -> exp np_doSuperExp . super_expU
    (73) super_expU -> . operatorR super_exp empty
    (74) super_expU -> . empty
    (63) operatorR -> . LESS np_addOperator empty
    (64) operatorR -> . GREATER np_addOperator empty
    (65) operatorR -> . LESSEQUAL np_addOperator empty
    (66) operatorR -> . GREATEREQUAL np_addOperator empty
    (67) operatorR -> . EQUALTO np_addOperator empty
    (68) operatorR -> . DIFF np_addOperator empty
    (89) empty -> .

    LESS            shift and go to state 184
    GREATER         shift and go to state 185
    LESSEQUAL       shift and go to state 186
    GREATEREQUAL    shift and go to state 187
    EQUALTO         shift and go to state 188
    DIFF            shift and go to state 189
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    super_expU                     shift and go to state 181
    operatorR                      shift and go to state 182
    empty                          shift and go to state 183

state 149

    (75) exp -> term np_doExp . expU
    (76) expU -> . operatorA exp
    (77) expU -> . empty
    (57) operatorA -> . PLUS np_addOperator empty
    (58) operatorA -> . MINUS np_addOperator empty
    (89) empty -> .

    PLUS            shift and go to state 193
    MINUS           shift and go to state 194
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    expU                           shift and go to state 190
    operatorA                      shift and go to state 191
    empty                          shift and go to state 192

state 150

    (78) term -> factor np_doTerm . termU
    (79) termU -> . operatorT term
    (80) termU -> . empty
    (59) operatorT -> . MULT np_addOperator empty
    (60) operatorT -> . DIV np_addOperator empty
    (89) empty -> .

    MULT            shift and go to state 198
    DIV             shift and go to state 199
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    termU                          shift and go to state 195
    operatorT                      shift and go to state 196
    empty                          shift and go to state 197

state 151

    (81) factor -> varcte empty .

    MULT            reduce using rule 81 (factor -> varcte empty .)
    DIV             reduce using rule 81 (factor -> varcte empty .)
    PLUS            reduce using rule 81 (factor -> varcte empty .)
    MINUS           reduce using rule 81 (factor -> varcte empty .)
    LESS            reduce using rule 81 (factor -> varcte empty .)
    GREATER         reduce using rule 81 (factor -> varcte empty .)
    LESSEQUAL       reduce using rule 81 (factor -> varcte empty .)
    GREATEREQUAL    reduce using rule 81 (factor -> varcte empty .)
    EQUALTO         reduce using rule 81 (factor -> varcte empty .)
    DIFF            reduce using rule 81 (factor -> varcte empty .)
    OR              reduce using rule 81 (factor -> varcte empty .)
    AND             reduce using rule 81 (factor -> varcte empty .)
    R_PAREN         reduce using rule 81 (factor -> varcte empty .)
    R_BRACKET       reduce using rule 81 (factor -> varcte empty .)
    COMA            reduce using rule 81 (factor -> varcte empty .)
    SEMICOLON       reduce using rule 81 (factor -> varcte empty .)
    DO              reduce using rule 81 (factor -> varcte empty .)


state 152

    (82) factor -> call np_isExpression . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 200

state 153

    (84) varcte -> ID np_addID . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 201

state 154

    (85) varcte -> ID L_BRACKET . np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (99) np_fakeBottom -> .

    L_PAREN         reduce using rule 99 (np_fakeBottom -> .)
    ID              reduce using rule 99 (np_fakeBottom -> .)
    INTVAL          reduce using rule 99 (np_fakeBottom -> .)
    FLOATVAL        reduce using rule 99 (np_fakeBottom -> .)
    CHARVAL         reduce using rule 99 (np_fakeBottom -> .)

    np_fakeBottom                  shift and go to state 202

state 155

    (86) varcte -> INTVAL np_addConstInt . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 203

state 156

    (87) varcte -> FLOATVAL np_addConstFloat . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 204

state 157

    (88) varcte -> CHARVAL np_addConstChar . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 205

state 158

    (47) read -> READ L_PAREN ID np_read . R_PAREN empty

    R_PAREN         shift and go to state 206


state 159

    (48) write -> WRITE L_PAREN writeD R_PAREN . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)

    empty                          shift and go to state 207

state 160

    (49) writeD -> hyper_exp np_write . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 208

state 161

    (50) writeD -> STRING np_string . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 209

state 162

    (51) decision -> IF L_PAREN hyper_exp R_PAREN . np_startDecision THEN block decisionU np_endDecision empty
    (118) np_startDecision -> .

    THEN            reduce using rule 118 (np_startDecision -> .)

    np_startDecision               shift and go to state 210

state 163

    (54) conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp . np_conditionalDuring R_PAREN DO block np_conditionalAfter empty
    (122) np_conditionalDuring -> .

    R_PAREN         reduce using rule 122 (np_conditionalDuring -> .)

    np_conditionalDuring           shift and go to state 211

state 164

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN . TO hyper_exp np_boolFor DO block np_endCondition empty

    TO              shift and go to state 212


state 165

    (56) for_assignment -> ID np_addIDFor . EQUAL np_addOperator hyper_exp np_for_assignment empty

    EQUAL           shift and go to state 213


state 166

    (21) receive_params -> ID COLON var_type np_receiveParams receive_paramsD . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 214

state 167

    (24) receive_paramsD -> empty .

    R_PAREN         reduce using rule 24 (receive_paramsD -> empty .)


state 168

    (23) receive_paramsD -> COMA . receive_params empty
    (21) receive_params -> . ID COLON var_type np_receiveParams receive_paramsD empty
    (22) receive_params -> . empty
    (89) empty -> .

    ID              shift and go to state 52
    R_PAREN         reduce using rule 89 (empty -> .)

    receive_params                 shift and go to state 215
    empty                          shift and go to state 54

state 169

    (11) functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction . functionsD
    (12) functionsD -> . functions
    (13) functionsD -> . empty
    (9) functions -> . functionsU
    (10) functions -> . empty
    (89) empty -> .
    (11) functionsU -> . func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD
    (14) func_type -> . INT empty
    (15) func_type -> . FLOAT empty
    (16) func_type -> . CHAR empty
    (17) func_type -> . VOID empty

    MAIN            reduce using rule 89 (empty -> .)
    INT             shift and go to state 13
    FLOAT           shift and go to state 14
    CHAR            shift and go to state 15
    VOID            shift and go to state 16

    func_type                      shift and go to state 12
    functionsD                     shift and go to state 216
    functions                      shift and go to state 217
    empty                          shift and go to state 218
    functionsU                     shift and go to state 11

state 170

    (43) assignment -> ID np_addID EQUAL np_addOperator hyper_exp . np_assignment empty
    (113) np_assignment -> .

    SEMICOLON       reduce using rule 113 (np_assignment -> .)

    np_assignment                  shift and go to state 219

state 171

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET . np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty
    (100) np_addArrayID -> .

    EQUAL           reduce using rule 100 (np_addArrayID -> .)

    np_addArrayID                  shift and go to state 220

state 172

    (45) call -> ID np_call_era L_PAREN send_params np_paramValidation . R_PAREN np_call_gosub empty

    R_PAREN         shift and go to state 221


state 173

    (25) send_params -> hyper_exp np_sentParam . send_paramsD empty
    (27) send_paramsD -> . COMA send_params empty
    (28) send_paramsD -> . empty
    (89) empty -> .

    COMA            shift and go to state 224
    R_PAREN         reduce using rule 89 (empty -> .)

    send_paramsD                   shift and go to state 222
    empty                          shift and go to state 223

state 174

    (83) factor -> L_PAREN hyper_exp R_PAREN . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 225

state 175

    (46) return -> RETURN L_PAREN hyper_exp np_return R_PAREN . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)

    empty                          shift and go to state 226

state 176

    (69) hyper_exp -> super_exp np_doHyperExp hyper_expU .

    R_PAREN         reduce using rule 69 (hyper_exp -> super_exp np_doHyperExp hyper_expU .)
    R_BRACKET       reduce using rule 69 (hyper_exp -> super_exp np_doHyperExp hyper_expU .)
    COMA            reduce using rule 69 (hyper_exp -> super_exp np_doHyperExp hyper_expU .)
    SEMICOLON       reduce using rule 69 (hyper_exp -> super_exp np_doHyperExp hyper_expU .)
    DO              reduce using rule 69 (hyper_exp -> super_exp np_doHyperExp hyper_expU .)


state 177

    (70) hyper_expU -> operatorL . hyper_exp empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 227
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 178

    (71) hyper_expU -> empty .

    R_PAREN         reduce using rule 71 (hyper_expU -> empty .)
    R_BRACKET       reduce using rule 71 (hyper_expU -> empty .)
    COMA            reduce using rule 71 (hyper_expU -> empty .)
    SEMICOLON       reduce using rule 71 (hyper_expU -> empty .)
    DO              reduce using rule 71 (hyper_expU -> empty .)


state 179

    (61) operatorL -> OR . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 228

state 180

    (62) operatorL -> AND . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 229

state 181

    (72) super_exp -> exp np_doSuperExp super_expU .

    OR              reduce using rule 72 (super_exp -> exp np_doSuperExp super_expU .)
    AND             reduce using rule 72 (super_exp -> exp np_doSuperExp super_expU .)
    R_PAREN         reduce using rule 72 (super_exp -> exp np_doSuperExp super_expU .)
    R_BRACKET       reduce using rule 72 (super_exp -> exp np_doSuperExp super_expU .)
    COMA            reduce using rule 72 (super_exp -> exp np_doSuperExp super_expU .)
    SEMICOLON       reduce using rule 72 (super_exp -> exp np_doSuperExp super_expU .)
    DO              reduce using rule 72 (super_exp -> exp np_doSuperExp super_expU .)


state 182

    (73) super_expU -> operatorR . super_exp empty
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    super_exp                      shift and go to state 230
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 183

    (74) super_expU -> empty .

    OR              reduce using rule 74 (super_expU -> empty .)
    AND             reduce using rule 74 (super_expU -> empty .)
    R_PAREN         reduce using rule 74 (super_expU -> empty .)
    R_BRACKET       reduce using rule 74 (super_expU -> empty .)
    COMA            reduce using rule 74 (super_expU -> empty .)
    SEMICOLON       reduce using rule 74 (super_expU -> empty .)
    DO              reduce using rule 74 (super_expU -> empty .)


state 184

    (63) operatorR -> LESS . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 231

state 185

    (64) operatorR -> GREATER . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 232

state 186

    (65) operatorR -> LESSEQUAL . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 233

state 187

    (66) operatorR -> GREATEREQUAL . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 234

state 188

    (67) operatorR -> EQUALTO . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 235

state 189

    (68) operatorR -> DIFF . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 236

state 190

    (75) exp -> term np_doExp expU .

    LESS            reduce using rule 75 (exp -> term np_doExp expU .)
    GREATER         reduce using rule 75 (exp -> term np_doExp expU .)
    LESSEQUAL       reduce using rule 75 (exp -> term np_doExp expU .)
    GREATEREQUAL    reduce using rule 75 (exp -> term np_doExp expU .)
    EQUALTO         reduce using rule 75 (exp -> term np_doExp expU .)
    DIFF            reduce using rule 75 (exp -> term np_doExp expU .)
    OR              reduce using rule 75 (exp -> term np_doExp expU .)
    AND             reduce using rule 75 (exp -> term np_doExp expU .)
    R_PAREN         reduce using rule 75 (exp -> term np_doExp expU .)
    R_BRACKET       reduce using rule 75 (exp -> term np_doExp expU .)
    COMA            reduce using rule 75 (exp -> term np_doExp expU .)
    SEMICOLON       reduce using rule 75 (exp -> term np_doExp expU .)
    DO              reduce using rule 75 (exp -> term np_doExp expU .)


state 191

    (76) expU -> operatorA . exp
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    exp                            shift and go to state 237
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 192

    (77) expU -> empty .

    LESS            reduce using rule 77 (expU -> empty .)
    GREATER         reduce using rule 77 (expU -> empty .)
    LESSEQUAL       reduce using rule 77 (expU -> empty .)
    GREATEREQUAL    reduce using rule 77 (expU -> empty .)
    EQUALTO         reduce using rule 77 (expU -> empty .)
    DIFF            reduce using rule 77 (expU -> empty .)
    OR              reduce using rule 77 (expU -> empty .)
    AND             reduce using rule 77 (expU -> empty .)
    R_PAREN         reduce using rule 77 (expU -> empty .)
    R_BRACKET       reduce using rule 77 (expU -> empty .)
    COMA            reduce using rule 77 (expU -> empty .)
    SEMICOLON       reduce using rule 77 (expU -> empty .)
    DO              reduce using rule 77 (expU -> empty .)


state 193

    (57) operatorA -> PLUS . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 238

state 194

    (58) operatorA -> MINUS . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 239

state 195

    (78) term -> factor np_doTerm termU .

    PLUS            reduce using rule 78 (term -> factor np_doTerm termU .)
    MINUS           reduce using rule 78 (term -> factor np_doTerm termU .)
    LESS            reduce using rule 78 (term -> factor np_doTerm termU .)
    GREATER         reduce using rule 78 (term -> factor np_doTerm termU .)
    LESSEQUAL       reduce using rule 78 (term -> factor np_doTerm termU .)
    GREATEREQUAL    reduce using rule 78 (term -> factor np_doTerm termU .)
    EQUALTO         reduce using rule 78 (term -> factor np_doTerm termU .)
    DIFF            reduce using rule 78 (term -> factor np_doTerm termU .)
    OR              reduce using rule 78 (term -> factor np_doTerm termU .)
    AND             reduce using rule 78 (term -> factor np_doTerm termU .)
    R_PAREN         reduce using rule 78 (term -> factor np_doTerm termU .)
    R_BRACKET       reduce using rule 78 (term -> factor np_doTerm termU .)
    COMA            reduce using rule 78 (term -> factor np_doTerm termU .)
    SEMICOLON       reduce using rule 78 (term -> factor np_doTerm termU .)
    DO              reduce using rule 78 (term -> factor np_doTerm termU .)


state 196

    (79) termU -> operatorT . term
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    term                           shift and go to state 240
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 197

    (80) termU -> empty .

    PLUS            reduce using rule 80 (termU -> empty .)
    MINUS           reduce using rule 80 (termU -> empty .)
    LESS            reduce using rule 80 (termU -> empty .)
    GREATER         reduce using rule 80 (termU -> empty .)
    LESSEQUAL       reduce using rule 80 (termU -> empty .)
    GREATEREQUAL    reduce using rule 80 (termU -> empty .)
    EQUALTO         reduce using rule 80 (termU -> empty .)
    DIFF            reduce using rule 80 (termU -> empty .)
    OR              reduce using rule 80 (termU -> empty .)
    AND             reduce using rule 80 (termU -> empty .)
    R_PAREN         reduce using rule 80 (termU -> empty .)
    R_BRACKET       reduce using rule 80 (termU -> empty .)
    COMA            reduce using rule 80 (termU -> empty .)
    SEMICOLON       reduce using rule 80 (termU -> empty .)
    DO              reduce using rule 80 (termU -> empty .)


state 198

    (59) operatorT -> MULT . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 241

state 199

    (60) operatorT -> DIV . np_addOperator empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 242

state 200

    (82) factor -> call np_isExpression empty .

    MULT            reduce using rule 82 (factor -> call np_isExpression empty .)
    DIV             reduce using rule 82 (factor -> call np_isExpression empty .)
    PLUS            reduce using rule 82 (factor -> call np_isExpression empty .)
    MINUS           reduce using rule 82 (factor -> call np_isExpression empty .)
    LESS            reduce using rule 82 (factor -> call np_isExpression empty .)
    GREATER         reduce using rule 82 (factor -> call np_isExpression empty .)
    LESSEQUAL       reduce using rule 82 (factor -> call np_isExpression empty .)
    GREATEREQUAL    reduce using rule 82 (factor -> call np_isExpression empty .)
    EQUALTO         reduce using rule 82 (factor -> call np_isExpression empty .)
    DIFF            reduce using rule 82 (factor -> call np_isExpression empty .)
    OR              reduce using rule 82 (factor -> call np_isExpression empty .)
    AND             reduce using rule 82 (factor -> call np_isExpression empty .)
    R_PAREN         reduce using rule 82 (factor -> call np_isExpression empty .)
    R_BRACKET       reduce using rule 82 (factor -> call np_isExpression empty .)
    COMA            reduce using rule 82 (factor -> call np_isExpression empty .)
    SEMICOLON       reduce using rule 82 (factor -> call np_isExpression empty .)
    DO              reduce using rule 82 (factor -> call np_isExpression empty .)


state 201

    (84) varcte -> ID np_addID empty .

    MULT            reduce using rule 84 (varcte -> ID np_addID empty .)
    DIV             reduce using rule 84 (varcte -> ID np_addID empty .)
    PLUS            reduce using rule 84 (varcte -> ID np_addID empty .)
    MINUS           reduce using rule 84 (varcte -> ID np_addID empty .)
    LESS            reduce using rule 84 (varcte -> ID np_addID empty .)
    GREATER         reduce using rule 84 (varcte -> ID np_addID empty .)
    LESSEQUAL       reduce using rule 84 (varcte -> ID np_addID empty .)
    GREATEREQUAL    reduce using rule 84 (varcte -> ID np_addID empty .)
    EQUALTO         reduce using rule 84 (varcte -> ID np_addID empty .)
    DIFF            reduce using rule 84 (varcte -> ID np_addID empty .)
    OR              reduce using rule 84 (varcte -> ID np_addID empty .)
    AND             reduce using rule 84 (varcte -> ID np_addID empty .)
    R_PAREN         reduce using rule 84 (varcte -> ID np_addID empty .)
    R_BRACKET       reduce using rule 84 (varcte -> ID np_addID empty .)
    COMA            reduce using rule 84 (varcte -> ID np_addID empty .)
    SEMICOLON       reduce using rule 84 (varcte -> ID np_addID empty .)
    DO              reduce using rule 84 (varcte -> ID np_addID empty .)


state 202

    (85) varcte -> ID L_BRACKET np_fakeBottom . hyper_exp R_BRACKET np_addArrayID empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 243
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 203

    (86) varcte -> INTVAL np_addConstInt empty .

    MULT            reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    DIV             reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    PLUS            reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    MINUS           reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    LESS            reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    GREATER         reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    LESSEQUAL       reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    GREATEREQUAL    reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    EQUALTO         reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    DIFF            reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    OR              reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    AND             reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    R_PAREN         reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    R_BRACKET       reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    COMA            reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    SEMICOLON       reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)
    DO              reduce using rule 86 (varcte -> INTVAL np_addConstInt empty .)


state 204

    (87) varcte -> FLOATVAL np_addConstFloat empty .

    MULT            reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    DIV             reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    PLUS            reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    MINUS           reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    LESS            reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    GREATER         reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    LESSEQUAL       reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    GREATEREQUAL    reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    EQUALTO         reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    DIFF            reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    OR              reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    AND             reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    R_PAREN         reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    R_BRACKET       reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    COMA            reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    SEMICOLON       reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)
    DO              reduce using rule 87 (varcte -> FLOATVAL np_addConstFloat empty .)


state 205

    (88) varcte -> CHARVAL np_addConstChar empty .

    MULT            reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    DIV             reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    PLUS            reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    MINUS           reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    LESS            reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    GREATER         reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    LESSEQUAL       reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    GREATEREQUAL    reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    EQUALTO         reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    DIFF            reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    OR              reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    AND             reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    R_PAREN         reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    R_BRACKET       reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    COMA            reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    SEMICOLON       reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)
    DO              reduce using rule 88 (varcte -> CHARVAL np_addConstChar empty .)


state 206

    (47) read -> READ L_PAREN ID np_read R_PAREN . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)

    empty                          shift and go to state 244

state 207

    (48) write -> WRITE L_PAREN writeD R_PAREN empty .

    SEMICOLON       reduce using rule 48 (write -> WRITE L_PAREN writeD R_PAREN empty .)


state 208

    (49) writeD -> hyper_exp np_write empty .

    R_PAREN         reduce using rule 49 (writeD -> hyper_exp np_write empty .)


state 209

    (50) writeD -> STRING np_string empty .

    R_PAREN         reduce using rule 50 (writeD -> STRING np_string empty .)


state 210

    (51) decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision . THEN block decisionU np_endDecision empty

    THEN            shift and go to state 245


state 211

    (54) conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring . R_PAREN DO block np_conditionalAfter empty

    R_PAREN         shift and go to state 246


state 212

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN TO . hyper_exp np_boolFor DO block np_endCondition empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 247
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 213

    (56) for_assignment -> ID np_addIDFor EQUAL . np_addOperator hyper_exp np_for_assignment empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 248

state 214

    (21) receive_params -> ID COLON var_type np_receiveParams receive_paramsD empty .

    R_PAREN         reduce using rule 21 (receive_params -> ID COLON var_type np_receiveParams receive_paramsD empty .)


state 215

    (23) receive_paramsD -> COMA receive_params . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 249

state 216

    (11) functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD .

    MAIN            reduce using rule 11 (functionsU -> func_type FUNCTION ID np_addFunction L_PAREN receive_params R_PAREN variables block np_endFunction functionsD .)


state 217

    (12) functionsD -> functions .

    MAIN            reduce using rule 12 (functionsD -> functions .)


state 218

    (13) functionsD -> empty .
    (10) functions -> empty .

  ! reduce/reduce conflict for MAIN resolved using rule 10 (functions -> empty .)
    MAIN            reduce using rule 10 (functions -> empty .)

  ! MAIN            [ reduce using rule 13 (functionsD -> empty .) ]


state 219

    (43) assignment -> ID np_addID EQUAL np_addOperator hyper_exp np_assignment . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)

    empty                          shift and go to state 250

state 220

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID . EQUAL np_addOperator hyper_exp np_assignment empty

    EQUAL           shift and go to state 251


state 221

    (45) call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN . np_call_gosub empty
    (105) np_call_gosub -> .

    SEMICOLON       reduce using rule 105 (np_call_gosub -> .)
    MULT            reduce using rule 105 (np_call_gosub -> .)
    DIV             reduce using rule 105 (np_call_gosub -> .)
    PLUS            reduce using rule 105 (np_call_gosub -> .)
    MINUS           reduce using rule 105 (np_call_gosub -> .)
    LESS            reduce using rule 105 (np_call_gosub -> .)
    GREATER         reduce using rule 105 (np_call_gosub -> .)
    LESSEQUAL       reduce using rule 105 (np_call_gosub -> .)
    GREATEREQUAL    reduce using rule 105 (np_call_gosub -> .)
    EQUALTO         reduce using rule 105 (np_call_gosub -> .)
    DIFF            reduce using rule 105 (np_call_gosub -> .)
    OR              reduce using rule 105 (np_call_gosub -> .)
    AND             reduce using rule 105 (np_call_gosub -> .)
    R_PAREN         reduce using rule 105 (np_call_gosub -> .)
    R_BRACKET       reduce using rule 105 (np_call_gosub -> .)
    COMA            reduce using rule 105 (np_call_gosub -> .)
    DO              reduce using rule 105 (np_call_gosub -> .)

    np_call_gosub                  shift and go to state 252

state 222

    (25) send_params -> hyper_exp np_sentParam send_paramsD . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 253

state 223

    (28) send_paramsD -> empty .

    R_PAREN         reduce using rule 28 (send_paramsD -> empty .)


state 224

    (27) send_paramsD -> COMA . send_params empty
    (25) send_params -> . hyper_exp np_sentParam send_paramsD empty
    (26) send_params -> . empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (89) empty -> .
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    R_PAREN         reduce using rule 89 (empty -> .)
    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    send_params                    shift and go to state 254
    empty                          shift and go to state 143
    hyper_exp                      shift and go to state 144
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 225

    (83) factor -> L_PAREN hyper_exp R_PAREN empty .

    MULT            reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    DIV             reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    PLUS            reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    MINUS           reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    LESS            reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    GREATER         reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    LESSEQUAL       reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    GREATEREQUAL    reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    EQUALTO         reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    DIFF            reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    OR              reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    AND             reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    R_PAREN         reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    R_BRACKET       reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    COMA            reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    SEMICOLON       reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)
    DO              reduce using rule 83 (factor -> L_PAREN hyper_exp R_PAREN empty .)


state 226

    (46) return -> RETURN L_PAREN hyper_exp np_return R_PAREN empty .

    SEMICOLON       reduce using rule 46 (return -> RETURN L_PAREN hyper_exp np_return R_PAREN empty .)


state 227

    (70) hyper_expU -> operatorL hyper_exp . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 255

state 228

    (61) operatorL -> OR np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 256

state 229

    (62) operatorL -> AND np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 257

state 230

    (73) super_expU -> operatorR super_exp . empty
    (89) empty -> .

    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 258

state 231

    (63) operatorR -> LESS np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 259

state 232

    (64) operatorR -> GREATER np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 260

state 233

    (65) operatorR -> LESSEQUAL np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 261

state 234

    (66) operatorR -> GREATEREQUAL np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 262

state 235

    (67) operatorR -> EQUALTO np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 263

state 236

    (68) operatorR -> DIFF np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 264

state 237

    (76) expU -> operatorA exp .

    LESS            reduce using rule 76 (expU -> operatorA exp .)
    GREATER         reduce using rule 76 (expU -> operatorA exp .)
    LESSEQUAL       reduce using rule 76 (expU -> operatorA exp .)
    GREATEREQUAL    reduce using rule 76 (expU -> operatorA exp .)
    EQUALTO         reduce using rule 76 (expU -> operatorA exp .)
    DIFF            reduce using rule 76 (expU -> operatorA exp .)
    OR              reduce using rule 76 (expU -> operatorA exp .)
    AND             reduce using rule 76 (expU -> operatorA exp .)
    R_PAREN         reduce using rule 76 (expU -> operatorA exp .)
    R_BRACKET       reduce using rule 76 (expU -> operatorA exp .)
    COMA            reduce using rule 76 (expU -> operatorA exp .)
    SEMICOLON       reduce using rule 76 (expU -> operatorA exp .)
    DO              reduce using rule 76 (expU -> operatorA exp .)


state 238

    (57) operatorA -> PLUS np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 265

state 239

    (58) operatorA -> MINUS np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 266

state 240

    (79) termU -> operatorT term .

    PLUS            reduce using rule 79 (termU -> operatorT term .)
    MINUS           reduce using rule 79 (termU -> operatorT term .)
    LESS            reduce using rule 79 (termU -> operatorT term .)
    GREATER         reduce using rule 79 (termU -> operatorT term .)
    LESSEQUAL       reduce using rule 79 (termU -> operatorT term .)
    GREATEREQUAL    reduce using rule 79 (termU -> operatorT term .)
    EQUALTO         reduce using rule 79 (termU -> operatorT term .)
    DIFF            reduce using rule 79 (termU -> operatorT term .)
    OR              reduce using rule 79 (termU -> operatorT term .)
    AND             reduce using rule 79 (termU -> operatorT term .)
    R_PAREN         reduce using rule 79 (termU -> operatorT term .)
    R_BRACKET       reduce using rule 79 (termU -> operatorT term .)
    COMA            reduce using rule 79 (termU -> operatorT term .)
    SEMICOLON       reduce using rule 79 (termU -> operatorT term .)
    DO              reduce using rule 79 (termU -> operatorT term .)


state 241

    (59) operatorT -> MULT np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 267

state 242

    (60) operatorT -> DIV np_addOperator . empty
    (89) empty -> .

    L_PAREN         reduce using rule 89 (empty -> .)
    ID              reduce using rule 89 (empty -> .)
    INTVAL          reduce using rule 89 (empty -> .)
    FLOATVAL        reduce using rule 89 (empty -> .)
    CHARVAL         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 268

state 243

    (85) varcte -> ID L_BRACKET np_fakeBottom hyper_exp . R_BRACKET np_addArrayID empty

    R_BRACKET       shift and go to state 269


state 244

    (47) read -> READ L_PAREN ID np_read R_PAREN empty .

    SEMICOLON       reduce using rule 47 (read -> READ L_PAREN ID np_read R_PAREN empty .)


state 245

    (51) decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN . block decisionU np_endDecision empty
    (29) block -> . L_BRACE blockU R_BRACE empty

    L_BRACE         shift and go to state 51

    block                          shift and go to state 270

state 246

    (54) conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN . DO block np_conditionalAfter empty

    DO              shift and go to state 271


state 247

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp . np_boolFor DO block np_endCondition empty
    (126) np_boolFor -> .

    DO              reduce using rule 126 (np_boolFor -> .)

    np_boolFor                     shift and go to state 272

state 248

    (56) for_assignment -> ID np_addIDFor EQUAL np_addOperator . hyper_exp np_for_assignment empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 273
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 249

    (23) receive_paramsD -> COMA receive_params empty .

    R_PAREN         reduce using rule 23 (receive_paramsD -> COMA receive_params empty .)


state 250

    (43) assignment -> ID np_addID EQUAL np_addOperator hyper_exp np_assignment empty .

    SEMICOLON       reduce using rule 43 (assignment -> ID np_addID EQUAL np_addOperator hyper_exp np_assignment empty .)


state 251

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL . np_addOperator hyper_exp np_assignment empty
    (108) np_addOperator -> .

    L_PAREN         reduce using rule 108 (np_addOperator -> .)
    ID              reduce using rule 108 (np_addOperator -> .)
    INTVAL          reduce using rule 108 (np_addOperator -> .)
    FLOATVAL        reduce using rule 108 (np_addOperator -> .)
    CHARVAL         reduce using rule 108 (np_addOperator -> .)

    np_addOperator                 shift and go to state 274

state 252

    (45) call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)
    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 275

state 253

    (25) send_params -> hyper_exp np_sentParam send_paramsD empty .

    R_PAREN         reduce using rule 25 (send_params -> hyper_exp np_sentParam send_paramsD empty .)


state 254

    (27) send_paramsD -> COMA send_params . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 276

state 255

    (70) hyper_expU -> operatorL hyper_exp empty .

    R_PAREN         reduce using rule 70 (hyper_expU -> operatorL hyper_exp empty .)
    R_BRACKET       reduce using rule 70 (hyper_expU -> operatorL hyper_exp empty .)
    COMA            reduce using rule 70 (hyper_expU -> operatorL hyper_exp empty .)
    SEMICOLON       reduce using rule 70 (hyper_expU -> operatorL hyper_exp empty .)
    DO              reduce using rule 70 (hyper_expU -> operatorL hyper_exp empty .)


state 256

    (61) operatorL -> OR np_addOperator empty .

    L_PAREN         reduce using rule 61 (operatorL -> OR np_addOperator empty .)
    ID              reduce using rule 61 (operatorL -> OR np_addOperator empty .)
    INTVAL          reduce using rule 61 (operatorL -> OR np_addOperator empty .)
    FLOATVAL        reduce using rule 61 (operatorL -> OR np_addOperator empty .)
    CHARVAL         reduce using rule 61 (operatorL -> OR np_addOperator empty .)


state 257

    (62) operatorL -> AND np_addOperator empty .

    L_PAREN         reduce using rule 62 (operatorL -> AND np_addOperator empty .)
    ID              reduce using rule 62 (operatorL -> AND np_addOperator empty .)
    INTVAL          reduce using rule 62 (operatorL -> AND np_addOperator empty .)
    FLOATVAL        reduce using rule 62 (operatorL -> AND np_addOperator empty .)
    CHARVAL         reduce using rule 62 (operatorL -> AND np_addOperator empty .)


state 258

    (73) super_expU -> operatorR super_exp empty .

    OR              reduce using rule 73 (super_expU -> operatorR super_exp empty .)
    AND             reduce using rule 73 (super_expU -> operatorR super_exp empty .)
    R_PAREN         reduce using rule 73 (super_expU -> operatorR super_exp empty .)
    R_BRACKET       reduce using rule 73 (super_expU -> operatorR super_exp empty .)
    COMA            reduce using rule 73 (super_expU -> operatorR super_exp empty .)
    SEMICOLON       reduce using rule 73 (super_expU -> operatorR super_exp empty .)
    DO              reduce using rule 73 (super_expU -> operatorR super_exp empty .)


state 259

    (63) operatorR -> LESS np_addOperator empty .

    L_PAREN         reduce using rule 63 (operatorR -> LESS np_addOperator empty .)
    ID              reduce using rule 63 (operatorR -> LESS np_addOperator empty .)
    INTVAL          reduce using rule 63 (operatorR -> LESS np_addOperator empty .)
    FLOATVAL        reduce using rule 63 (operatorR -> LESS np_addOperator empty .)
    CHARVAL         reduce using rule 63 (operatorR -> LESS np_addOperator empty .)


state 260

    (64) operatorR -> GREATER np_addOperator empty .

    L_PAREN         reduce using rule 64 (operatorR -> GREATER np_addOperator empty .)
    ID              reduce using rule 64 (operatorR -> GREATER np_addOperator empty .)
    INTVAL          reduce using rule 64 (operatorR -> GREATER np_addOperator empty .)
    FLOATVAL        reduce using rule 64 (operatorR -> GREATER np_addOperator empty .)
    CHARVAL         reduce using rule 64 (operatorR -> GREATER np_addOperator empty .)


state 261

    (65) operatorR -> LESSEQUAL np_addOperator empty .

    L_PAREN         reduce using rule 65 (operatorR -> LESSEQUAL np_addOperator empty .)
    ID              reduce using rule 65 (operatorR -> LESSEQUAL np_addOperator empty .)
    INTVAL          reduce using rule 65 (operatorR -> LESSEQUAL np_addOperator empty .)
    FLOATVAL        reduce using rule 65 (operatorR -> LESSEQUAL np_addOperator empty .)
    CHARVAL         reduce using rule 65 (operatorR -> LESSEQUAL np_addOperator empty .)


state 262

    (66) operatorR -> GREATEREQUAL np_addOperator empty .

    L_PAREN         reduce using rule 66 (operatorR -> GREATEREQUAL np_addOperator empty .)
    ID              reduce using rule 66 (operatorR -> GREATEREQUAL np_addOperator empty .)
    INTVAL          reduce using rule 66 (operatorR -> GREATEREQUAL np_addOperator empty .)
    FLOATVAL        reduce using rule 66 (operatorR -> GREATEREQUAL np_addOperator empty .)
    CHARVAL         reduce using rule 66 (operatorR -> GREATEREQUAL np_addOperator empty .)


state 263

    (67) operatorR -> EQUALTO np_addOperator empty .

    L_PAREN         reduce using rule 67 (operatorR -> EQUALTO np_addOperator empty .)
    ID              reduce using rule 67 (operatorR -> EQUALTO np_addOperator empty .)
    INTVAL          reduce using rule 67 (operatorR -> EQUALTO np_addOperator empty .)
    FLOATVAL        reduce using rule 67 (operatorR -> EQUALTO np_addOperator empty .)
    CHARVAL         reduce using rule 67 (operatorR -> EQUALTO np_addOperator empty .)


state 264

    (68) operatorR -> DIFF np_addOperator empty .

    L_PAREN         reduce using rule 68 (operatorR -> DIFF np_addOperator empty .)
    ID              reduce using rule 68 (operatorR -> DIFF np_addOperator empty .)
    INTVAL          reduce using rule 68 (operatorR -> DIFF np_addOperator empty .)
    FLOATVAL        reduce using rule 68 (operatorR -> DIFF np_addOperator empty .)
    CHARVAL         reduce using rule 68 (operatorR -> DIFF np_addOperator empty .)


state 265

    (57) operatorA -> PLUS np_addOperator empty .

    L_PAREN         reduce using rule 57 (operatorA -> PLUS np_addOperator empty .)
    ID              reduce using rule 57 (operatorA -> PLUS np_addOperator empty .)
    INTVAL          reduce using rule 57 (operatorA -> PLUS np_addOperator empty .)
    FLOATVAL        reduce using rule 57 (operatorA -> PLUS np_addOperator empty .)
    CHARVAL         reduce using rule 57 (operatorA -> PLUS np_addOperator empty .)


state 266

    (58) operatorA -> MINUS np_addOperator empty .

    L_PAREN         reduce using rule 58 (operatorA -> MINUS np_addOperator empty .)
    ID              reduce using rule 58 (operatorA -> MINUS np_addOperator empty .)
    INTVAL          reduce using rule 58 (operatorA -> MINUS np_addOperator empty .)
    FLOATVAL        reduce using rule 58 (operatorA -> MINUS np_addOperator empty .)
    CHARVAL         reduce using rule 58 (operatorA -> MINUS np_addOperator empty .)


state 267

    (59) operatorT -> MULT np_addOperator empty .

    L_PAREN         reduce using rule 59 (operatorT -> MULT np_addOperator empty .)
    ID              reduce using rule 59 (operatorT -> MULT np_addOperator empty .)
    INTVAL          reduce using rule 59 (operatorT -> MULT np_addOperator empty .)
    FLOATVAL        reduce using rule 59 (operatorT -> MULT np_addOperator empty .)
    CHARVAL         reduce using rule 59 (operatorT -> MULT np_addOperator empty .)


state 268

    (60) operatorT -> DIV np_addOperator empty .

    L_PAREN         reduce using rule 60 (operatorT -> DIV np_addOperator empty .)
    ID              reduce using rule 60 (operatorT -> DIV np_addOperator empty .)
    INTVAL          reduce using rule 60 (operatorT -> DIV np_addOperator empty .)
    FLOATVAL        reduce using rule 60 (operatorT -> DIV np_addOperator empty .)
    CHARVAL         reduce using rule 60 (operatorT -> DIV np_addOperator empty .)


state 269

    (85) varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET . np_addArrayID empty
    (100) np_addArrayID -> .

    MULT            reduce using rule 100 (np_addArrayID -> .)
    DIV             reduce using rule 100 (np_addArrayID -> .)
    PLUS            reduce using rule 100 (np_addArrayID -> .)
    MINUS           reduce using rule 100 (np_addArrayID -> .)
    LESS            reduce using rule 100 (np_addArrayID -> .)
    GREATER         reduce using rule 100 (np_addArrayID -> .)
    LESSEQUAL       reduce using rule 100 (np_addArrayID -> .)
    GREATEREQUAL    reduce using rule 100 (np_addArrayID -> .)
    EQUALTO         reduce using rule 100 (np_addArrayID -> .)
    DIFF            reduce using rule 100 (np_addArrayID -> .)
    OR              reduce using rule 100 (np_addArrayID -> .)
    AND             reduce using rule 100 (np_addArrayID -> .)
    R_PAREN         reduce using rule 100 (np_addArrayID -> .)
    R_BRACKET       reduce using rule 100 (np_addArrayID -> .)
    COMA            reduce using rule 100 (np_addArrayID -> .)
    SEMICOLON       reduce using rule 100 (np_addArrayID -> .)
    DO              reduce using rule 100 (np_addArrayID -> .)

    np_addArrayID                  shift and go to state 277

state 270

    (51) decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block . decisionU np_endDecision empty
    (52) decisionU -> . ELSE np_startDecisionElse block empty
    (53) decisionU -> . empty
    (89) empty -> .

    ELSE            shift and go to state 280
    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    decisionU                      shift and go to state 278
    empty                          shift and go to state 279

state 271

    (54) conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO . block np_conditionalAfter empty
    (29) block -> . L_BRACE blockU R_BRACE empty

    L_BRACE         shift and go to state 51

    block                          shift and go to state 281

state 272

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor . DO block np_endCondition empty

    DO              shift and go to state 282


state 273

    (56) for_assignment -> ID np_addIDFor EQUAL np_addOperator hyper_exp . np_for_assignment empty
    (125) np_for_assignment -> .

    R_PAREN         reduce using rule 125 (np_for_assignment -> .)

    np_for_assignment              shift and go to state 283

state 274

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator . hyper_exp np_assignment empty
    (69) hyper_exp -> . super_exp np_doHyperExp hyper_expU
    (72) super_exp -> . exp np_doSuperExp super_expU
    (75) exp -> . term np_doExp expU
    (78) term -> . factor np_doTerm termU
    (81) factor -> . varcte empty
    (82) factor -> . call np_isExpression empty
    (83) factor -> . L_PAREN hyper_exp R_PAREN empty
    (84) varcte -> . ID np_addID empty
    (85) varcte -> . ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty
    (86) varcte -> . INTVAL np_addConstInt empty
    (87) varcte -> . FLOATVAL np_addConstFloat empty
    (88) varcte -> . CHARVAL np_addConstChar empty
    (45) call -> . ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty

    L_PAREN         shift and go to state 115
    ID              shift and go to state 123
    INTVAL          shift and go to state 124
    FLOATVAL        shift and go to state 125
    CHARVAL         shift and go to state 126

    hyper_exp                      shift and go to state 284
    super_exp                      shift and go to state 117
    exp                            shift and go to state 118
    term                           shift and go to state 119
    factor                         shift and go to state 120
    varcte                         shift and go to state 121
    call                           shift and go to state 122

state 275

    (45) call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .

    SEMICOLON       reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    MULT            reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    DIV             reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    PLUS            reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    MINUS           reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    LESS            reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    GREATER         reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    LESSEQUAL       reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    GREATEREQUAL    reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    EQUALTO         reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    DIFF            reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    OR              reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    AND             reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    R_PAREN         reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    R_BRACKET       reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    COMA            reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)
    DO              reduce using rule 45 (call -> ID np_call_era L_PAREN send_params np_paramValidation R_PAREN np_call_gosub empty .)


state 276

    (27) send_paramsD -> COMA send_params empty .

    R_PAREN         reduce using rule 27 (send_paramsD -> COMA send_params empty .)


state 277

    (85) varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID . empty
    (89) empty -> .

    MULT            reduce using rule 89 (empty -> .)
    DIV             reduce using rule 89 (empty -> .)
    PLUS            reduce using rule 89 (empty -> .)
    MINUS           reduce using rule 89 (empty -> .)
    LESS            reduce using rule 89 (empty -> .)
    GREATER         reduce using rule 89 (empty -> .)
    LESSEQUAL       reduce using rule 89 (empty -> .)
    GREATEREQUAL    reduce using rule 89 (empty -> .)
    EQUALTO         reduce using rule 89 (empty -> .)
    DIFF            reduce using rule 89 (empty -> .)
    OR              reduce using rule 89 (empty -> .)
    AND             reduce using rule 89 (empty -> .)
    R_PAREN         reduce using rule 89 (empty -> .)
    R_BRACKET       reduce using rule 89 (empty -> .)
    COMA            reduce using rule 89 (empty -> .)
    SEMICOLON       reduce using rule 89 (empty -> .)
    DO              reduce using rule 89 (empty -> .)

    empty                          shift and go to state 285

state 278

    (51) decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU . np_endDecision empty
    (120) np_endDecision -> .

    ID              reduce using rule 120 (np_endDecision -> .)
    RETURN          reduce using rule 120 (np_endDecision -> .)
    READ            reduce using rule 120 (np_endDecision -> .)
    WRITE           reduce using rule 120 (np_endDecision -> .)
    IF              reduce using rule 120 (np_endDecision -> .)
    WHILE           reduce using rule 120 (np_endDecision -> .)
    FROM            reduce using rule 120 (np_endDecision -> .)
    R_BRACE         reduce using rule 120 (np_endDecision -> .)

    np_endDecision                 shift and go to state 286

state 279

    (53) decisionU -> empty .

    ID              reduce using rule 53 (decisionU -> empty .)
    RETURN          reduce using rule 53 (decisionU -> empty .)
    READ            reduce using rule 53 (decisionU -> empty .)
    WRITE           reduce using rule 53 (decisionU -> empty .)
    IF              reduce using rule 53 (decisionU -> empty .)
    WHILE           reduce using rule 53 (decisionU -> empty .)
    FROM            reduce using rule 53 (decisionU -> empty .)
    R_BRACE         reduce using rule 53 (decisionU -> empty .)


state 280

    (52) decisionU -> ELSE . np_startDecisionElse block empty
    (119) np_startDecisionElse -> .

    L_BRACE         reduce using rule 119 (np_startDecisionElse -> .)

    np_startDecisionElse           shift and go to state 287

state 281

    (54) conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block . np_conditionalAfter empty
    (123) np_conditionalAfter -> .

    ID              reduce using rule 123 (np_conditionalAfter -> .)
    RETURN          reduce using rule 123 (np_conditionalAfter -> .)
    READ            reduce using rule 123 (np_conditionalAfter -> .)
    WRITE           reduce using rule 123 (np_conditionalAfter -> .)
    IF              reduce using rule 123 (np_conditionalAfter -> .)
    WHILE           reduce using rule 123 (np_conditionalAfter -> .)
    FROM            reduce using rule 123 (np_conditionalAfter -> .)
    R_BRACE         reduce using rule 123 (np_conditionalAfter -> .)

    np_conditionalAfter            shift and go to state 288

state 282

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO . block np_endCondition empty
    (29) block -> . L_BRACE blockU R_BRACE empty

    L_BRACE         shift and go to state 51

    block                          shift and go to state 289

state 283

    (56) for_assignment -> ID np_addIDFor EQUAL np_addOperator hyper_exp np_for_assignment . empty
    (89) empty -> .

    R_PAREN         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 290

state 284

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp . np_assignment empty
    (113) np_assignment -> .

    SEMICOLON       reduce using rule 113 (np_assignment -> .)

    np_assignment                  shift and go to state 291

state 285

    (85) varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .

    MULT            reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    DIV             reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    PLUS            reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    MINUS           reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    LESS            reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    GREATER         reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    LESSEQUAL       reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    GREATEREQUAL    reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    EQUALTO         reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    DIFF            reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    OR              reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    AND             reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    R_PAREN         reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    R_BRACKET       reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    COMA            reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    SEMICOLON       reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)
    DO              reduce using rule 85 (varcte -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID empty .)


state 286

    (51) decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 292

state 287

    (52) decisionU -> ELSE np_startDecisionElse . block empty
    (29) block -> . L_BRACE blockU R_BRACE empty

    L_BRACE         shift and go to state 51

    block                          shift and go to state 293

state 288

    (54) conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 294

state 289

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block . np_endCondition empty
    (127) np_endCondition -> .

    ID              reduce using rule 127 (np_endCondition -> .)
    RETURN          reduce using rule 127 (np_endCondition -> .)
    READ            reduce using rule 127 (np_endCondition -> .)
    WRITE           reduce using rule 127 (np_endCondition -> .)
    IF              reduce using rule 127 (np_endCondition -> .)
    WHILE           reduce using rule 127 (np_endCondition -> .)
    FROM            reduce using rule 127 (np_endCondition -> .)
    R_BRACE         reduce using rule 127 (np_endCondition -> .)

    np_endCondition                shift and go to state 295

state 290

    (56) for_assignment -> ID np_addIDFor EQUAL np_addOperator hyper_exp np_for_assignment empty .

    R_PAREN         reduce using rule 56 (for_assignment -> ID np_addIDFor EQUAL np_addOperator hyper_exp np_for_assignment empty .)


state 291

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment . empty
    (89) empty -> .

    SEMICOLON       reduce using rule 89 (empty -> .)

    empty                          shift and go to state 296

state 292

    (51) decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .

    ID              reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)
    RETURN          reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)
    READ            reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)
    WRITE           reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)
    IF              reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)
    WHILE           reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)
    FROM            reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)
    R_BRACE         reduce using rule 51 (decision -> IF L_PAREN hyper_exp R_PAREN np_startDecision THEN block decisionU np_endDecision empty .)


state 293

    (52) decisionU -> ELSE np_startDecisionElse block . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 297

state 294

    (54) conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .

    ID              reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)
    RETURN          reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)
    READ            reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)
    WRITE           reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)
    IF              reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)
    WHILE           reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)
    FROM            reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)
    R_BRACE         reduce using rule 54 (conditional -> WHILE L_PAREN np_conditionalBefore hyper_exp np_conditionalDuring R_PAREN DO block np_conditionalAfter empty .)


state 295

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition . empty
    (89) empty -> .

    ID              reduce using rule 89 (empty -> .)
    RETURN          reduce using rule 89 (empty -> .)
    READ            reduce using rule 89 (empty -> .)
    WRITE           reduce using rule 89 (empty -> .)
    IF              reduce using rule 89 (empty -> .)
    WHILE           reduce using rule 89 (empty -> .)
    FROM            reduce using rule 89 (empty -> .)
    R_BRACE         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 298

state 296

    (44) assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty .

    SEMICOLON       reduce using rule 44 (assignment -> ID L_BRACKET np_fakeBottom hyper_exp R_BRACKET np_addArrayID EQUAL np_addOperator hyper_exp np_assignment empty .)


state 297

    (52) decisionU -> ELSE np_startDecisionElse block empty .

    ID              reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)
    RETURN          reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)
    READ            reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)
    WRITE           reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)
    IF              reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)
    WHILE           reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)
    FROM            reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)
    R_BRACE         reduce using rule 52 (decisionU -> ELSE np_startDecisionElse block empty .)


state 298

    (55) non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .

    ID              reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)
    RETURN          reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)
    READ            reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)
    WRITE           reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)
    IF              reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)
    WHILE           reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)
    FROM            reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)
    R_BRACE         reduce using rule 55 (non_conditional -> FROM L_PAREN for_assignment R_PAREN TO hyper_exp np_boolFor DO block np_endCondition empty .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 51 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 51 resolved as shift
WARNING: shift/reduce conflict for READ in state 51 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 51 resolved as shift
WARNING: shift/reduce conflict for IF in state 51 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 51 resolved as shift
WARNING: shift/reduce conflict for FROM in state 51 resolved as shift
WARNING: shift/reduce conflict for ID in state 60 resolved as shift
WARNING: shift/reduce conflict for RETURN in state 60 resolved as shift
WARNING: shift/reduce conflict for READ in state 60 resolved as shift
WARNING: shift/reduce conflict for WRITE in state 60 resolved as shift
WARNING: shift/reduce conflict for IF in state 60 resolved as shift
WARNING: shift/reduce conflict for WHILE in state 60 resolved as shift
WARNING: shift/reduce conflict for FROM in state 60 resolved as shift
WARNING: reduce/reduce conflict in state 59 resolved using rule (blockU -> empty)
WARNING: rejected rule (statement -> empty) in state 59
WARNING: reduce/reduce conflict in state 82 resolved using rule (blockU -> empty)
WARNING: rejected rule (blockD -> empty) in state 82
WARNING: reduce/reduce conflict in state 82 resolved using rule (blockU -> empty)
WARNING: rejected rule (statement -> empty) in state 82
WARNING: reduce/reduce conflict in state 218 resolved using rule (functions -> empty)
WARNING: rejected rule (functionsD -> empty) in state 218
WARNING: Rule (blockD -> empty) is never reduced
WARNING: Rule (functionsD -> empty) is never reduced
